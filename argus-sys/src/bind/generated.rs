/* automatically generated by rust-bindgen 0.71.1 */

#[allow(
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    clippy::missing_safety_doc
)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod __swappable_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub mod __swappable_with_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod __ops {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod Argus {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UUID {
            pub time_low: u32,
            pub time_mid: u16,
            pub time_hi_and_version: u16,
            pub clock_seq: u16,
            pub node: [u8; 6usize],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NamedUUID {
            pub _base: root::Argus::UUID,
            pub m_name: [::core::ffi::c_char; 32usize],
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Status {
            STATUS_OK = 0,
            STATUS_INVALID_PARAMS = 1,
            STATUS_INVALID_SETTINGS = 2,
            STATUS_UNAVAILABLE = 3,
            STATUS_OUT_OF_MEMORY = 4,
            STATUS_UNIMPLEMENTED = 5,
            STATUS_TIMEOUT = 6,
            STATUS_CANCELLED = 7,
            STATUS_DISCONNECTED = 8,
            STATUS_END_OF_STREAM = 9,
            STATUS_COUNT = 10,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RGBChannel {
            RGB_CHANNEL_R = 0,
            RGB_CHANNEL_G = 1,
            RGB_CHANNEL_B = 2,
            RGB_CHANNEL_COUNT = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AeAntibandingMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AeMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AeFlickerState {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AeState {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AwbMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AwbState {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AfMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CaptureIntent {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DenoiseMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EdgeEnhanceMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ExtensionName {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PixelFormat {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SensorModeType {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SensorPlacement {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BayerPhase {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PixelFormatType {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CVOutput {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        pub struct Interface {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InterfaceID {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        pub struct InterfaceProvider__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct InterfaceProvider {
            pub vtable_: *const InterfaceProvider__bindgen_vtable,
        }
        #[repr(C)]
        pub struct Destructable__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct Destructable {
            pub vtable_: *const Destructable__bindgen_vtable,
        }
        #[repr(C)]
        pub struct AcRegion {
            pub __bindgen_padding_0: [u32; 4usize],
            pub m_weight: f32,
        }
        pub type AutoControlId = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct StreamType {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        pub struct OutputStream {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct OutputStreamSettings {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct InputStream {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct InputStreamSettings {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BufferType {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        pub struct Buffer {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct BufferSettings {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct CameraDevice {
            pub _base: root::Argus::InterfaceProvider,
        }
        #[repr(C)]
        pub struct ICameraProperties__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ICameraProperties {
            pub vtable_: *const ICameraProperties__bindgen_vtable,
        }
        #[repr(C)]
        pub struct SensorMode {
            pub _base: root::Argus::InterfaceProvider,
        }
        #[repr(C)]
        pub struct ISensorMode__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ISensorMode {
            pub vtable_: *const ISensorMode__bindgen_vtable,
        }
        #[repr(C)]
        pub struct CameraProvider {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        impl CameraProvider {
            #[inline]
            pub unsafe fn create(
                status: *mut root::Argus::Status,
            ) -> *mut root::Argus::CameraProvider {
                CameraProvider_create(status)
            }
        }
        #[repr(C)]
        pub struct ICameraProvider__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ICameraProvider {
            pub vtable_: *const ICameraProvider__bindgen_vtable,
        }
        #[repr(C)]
        pub struct CaptureMetadata {
            pub _base: root::Argus::InterfaceProvider,
        }
        #[repr(C)]
        pub struct ICaptureMetadata__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ICaptureMetadata {
            pub vtable_: *const ICaptureMetadata__bindgen_vtable,
        }
        pub const ICaptureMetadata_NUM_COLOR_CORRECTION_ELEMENTS: u32 = 9;
        pub const ICaptureMetadata_NUM_AWB_WB_ESTIMATE_ELEMENTS: u32 = 4;
        #[repr(C)]
        pub struct CaptureSession {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct ICaptureSession__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ICaptureSession {
            pub vtable_: *const ICaptureSession__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EGLStreamMode {
            pub _base: root::Argus::NamedUUID,
        }
        #[repr(C)]
        pub struct IEGLOutputStreamSettings__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IEGLOutputStreamSettings {
            pub vtable_: *const IEGLOutputStreamSettings__bindgen_vtable,
        }
        #[repr(C)]
        pub struct Request {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct IRequest__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IRequest {
            pub vtable_: *const IRequest__bindgen_vtable,
        }
        #[repr(C)]
        pub struct ISourceSettings__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct ISourceSettings {
            pub vtable_: *const ISourceSettings__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAutoControlSettings__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IAutoControlSettings {
            pub vtable_: *const IAutoControlSettings__bindgen_vtable,
        }
        pub mod Ext {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct IDeFogSettings__bindgen_vtable(::core::ffi::c_void);
            #[repr(C)]
            pub struct IDeFogSettings {
                pub vtable_: *const IDeFogSettings__bindgen_vtable,
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}_ZN5Argus14CameraProvider6createEPNS_6StatusE"]
            pub fn CameraProvider_create(
                status: *mut root::Argus::Status,
            ) -> *mut root::Argus::CameraProvider;
        }
    }
    pub mod __gnu_debug {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub mod __cxxabiv1 {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type EGLDisplay = *mut ::core::ffi::c_void;
    pub type EGLStreamKHR = *mut ::core::ffi::c_void;
    pub mod EGLStream {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct IArgusCaptureMetadata__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IArgusCaptureMetadata {
            pub vtable_: *const IArgusCaptureMetadata__bindgen_vtable,
        }
        #[repr(C)]
        pub struct Frame {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        #[repr(C)]
        pub struct IFrame__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IFrame {
            pub vtable_: *const IFrame__bindgen_vtable,
        }
        #[repr(C)]
        pub struct FrameConsumer {
            pub _base: root::Argus::InterfaceProvider,
            pub _base_1: root::Argus::Destructable,
        }
        impl FrameConsumer {
            #[inline]
            pub unsafe fn create(
                outputStream: *mut root::Argus::OutputStream,
                status: *mut root::Argus::Status,
            ) -> *mut root::EGLStream::FrameConsumer {
                FrameConsumer_create(outputStream, status)
            }
            #[inline]
            pub unsafe fn create1(
                eglDisplay: root::EGLDisplay,
                eglStream: root::EGLStreamKHR,
                status: *mut root::Argus::Status,
            ) -> *mut root::EGLStream::FrameConsumer {
                FrameConsumer_create1(eglDisplay, eglStream, status)
            }
        }
        #[repr(C)]
        pub struct IFrameConsumer__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IFrameConsumer {
            pub vtable_: *const IFrameConsumer__bindgen_vtable,
        }
        #[repr(C)]
        pub struct Image {
            pub _base: root::Argus::InterfaceProvider,
        }
        #[repr(C)]
        pub struct IImage__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IImage {
            pub vtable_: *const IImage__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IImage2D__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IImage2D {
            pub vtable_: *const IImage2D__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IImageJPEG__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        pub struct IImageJPEG {
            pub vtable_: *const IImageJPEG__bindgen_vtable,
        }
        pub mod NV {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Rotation {
                ROTATION_0 = 0,
                ROTATION_90 = 1,
                ROTATION_180 = 2,
                ROTATION_270 = 3,
                ROTATION_COUNT = 4,
            }
            #[repr(C)]
            pub struct IImageNativeBuffer__bindgen_vtable(::core::ffi::c_void);
            #[repr(C)]
            pub struct IImageNativeBuffer {
                pub vtable_: *const IImageNativeBuffer__bindgen_vtable,
            }
        }
        unsafe extern "C" {
            #[link_name = "\u{1}_ZN9EGLStream13FrameConsumer6createEPN5Argus12OutputStreamEPNS1_6StatusE"]
            pub fn FrameConsumer_create(
                outputStream: *mut root::Argus::OutputStream,
                status: *mut root::Argus::Status,
            ) -> *mut root::EGLStream::FrameConsumer;
            #[link_name = "\u{1}_ZN9EGLStream13FrameConsumer6createEPvS1_PN5Argus6StatusE"]
            pub fn FrameConsumer_create1(
                eglDisplay: root::EGLDisplay,
                eglStream: root::EGLStreamKHR,
                status: *mut root::Argus::Status,
            ) -> *mut root::EGLStream::FrameConsumer;
        }
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum NvBufSurfaceMemMapFlags {
        NVBUF_MAP_READ = 0,
        NVBUF_MAP_WRITE = 1,
        NVBUF_MAP_READ_WRITE = 2,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum NvBufSurfaceColorFormat {
        NVBUF_COLOR_FORMAT_INVALID = 0,
        NVBUF_COLOR_FORMAT_GRAY8 = 1,
        NVBUF_COLOR_FORMAT_YUV420 = 2,
        NVBUF_COLOR_FORMAT_YVU420 = 3,
        NVBUF_COLOR_FORMAT_YUV420_ER = 4,
        NVBUF_COLOR_FORMAT_YVU420_ER = 5,
        NVBUF_COLOR_FORMAT_NV12 = 6,
        NVBUF_COLOR_FORMAT_NV12_ER = 7,
        NVBUF_COLOR_FORMAT_NV21 = 8,
        NVBUF_COLOR_FORMAT_NV21_ER = 9,
        NVBUF_COLOR_FORMAT_UYVY = 10,
        NVBUF_COLOR_FORMAT_UYVY_ER = 11,
        NVBUF_COLOR_FORMAT_VYUY = 12,
        NVBUF_COLOR_FORMAT_VYUY_ER = 13,
        NVBUF_COLOR_FORMAT_YUYV = 14,
        NVBUF_COLOR_FORMAT_YUYV_ER = 15,
        NVBUF_COLOR_FORMAT_YVYU = 16,
        NVBUF_COLOR_FORMAT_YVYU_ER = 17,
        NVBUF_COLOR_FORMAT_YUV444 = 18,
        NVBUF_COLOR_FORMAT_RGBA = 19,
        NVBUF_COLOR_FORMAT_BGRA = 20,
        NVBUF_COLOR_FORMAT_ARGB = 21,
        NVBUF_COLOR_FORMAT_ABGR = 22,
        NVBUF_COLOR_FORMAT_RGBx = 23,
        NVBUF_COLOR_FORMAT_BGRx = 24,
        NVBUF_COLOR_FORMAT_xRGB = 25,
        NVBUF_COLOR_FORMAT_xBGR = 26,
        NVBUF_COLOR_FORMAT_RGB = 27,
        NVBUF_COLOR_FORMAT_BGR = 28,
        NVBUF_COLOR_FORMAT_NV12_10LE = 29,
        NVBUF_COLOR_FORMAT_NV12_12LE = 30,
        NVBUF_COLOR_FORMAT_YUV420_709 = 31,
        NVBUF_COLOR_FORMAT_YUV420_709_ER = 32,
        NVBUF_COLOR_FORMAT_NV12_709 = 33,
        NVBUF_COLOR_FORMAT_NV12_709_ER = 34,
        NVBUF_COLOR_FORMAT_YUV420_2020 = 35,
        NVBUF_COLOR_FORMAT_NV12_2020 = 36,
        NVBUF_COLOR_FORMAT_NV12_10LE_ER = 37,
        NVBUF_COLOR_FORMAT_NV12_10LE_709 = 38,
        NVBUF_COLOR_FORMAT_NV12_10LE_709_ER = 39,
        NVBUF_COLOR_FORMAT_NV12_10LE_2020 = 40,
        NVBUF_COLOR_FORMAT_SIGNED_R16G16 = 41,
        NVBUF_COLOR_FORMAT_R8_G8_B8 = 42,
        NVBUF_COLOR_FORMAT_B8_G8_R8 = 43,
        NVBUF_COLOR_FORMAT_R32F_G32F_B32F = 44,
        NVBUF_COLOR_FORMAT_B32F_G32F_R32F = 45,
        NVBUF_COLOR_FORMAT_YUV422 = 46,
        NVBUF_COLOR_FORMAT_NV21_10LE = 47,
        NVBUF_COLOR_FORMAT_NV21_12LE = 48,
        NVBUF_COLOR_FORMAT_NV12_12LE_2020 = 49,
        NVBUF_COLOR_FORMAT_NV16 = 50,
        NVBUF_COLOR_FORMAT_NV16_10LE = 51,
        NVBUF_COLOR_FORMAT_NV24 = 52,
        NVBUF_COLOR_FORMAT_NV24_10LE = 53,
        NVBUF_COLOR_FORMAT_NV16_ER = 54,
        NVBUF_COLOR_FORMAT_NV24_ER = 55,
        NVBUF_COLOR_FORMAT_NV16_709 = 56,
        NVBUF_COLOR_FORMAT_NV24_709 = 57,
        NVBUF_COLOR_FORMAT_NV16_709_ER = 58,
        NVBUF_COLOR_FORMAT_NV24_709_ER = 59,
        NVBUF_COLOR_FORMAT_NV24_10LE_709 = 60,
        NVBUF_COLOR_FORMAT_NV24_10LE_709_ER = 61,
        NVBUF_COLOR_FORMAT_NV24_10LE_2020 = 62,
        NVBUF_COLOR_FORMAT_NV24_12LE_2020 = 63,
        NVBUF_COLOR_FORMAT_RGBA_10_10_10_2_709 = 64,
        NVBUF_COLOR_FORMAT_RGBA_10_10_10_2_2020 = 65,
        NVBUF_COLOR_FORMAT_BGRA_10_10_10_2_709 = 66,
        NVBUF_COLOR_FORMAT_BGRA_10_10_10_2_2020 = 67,
        NVBUF_COLOR_FORMAT_A32 = 68,
        NVBUF_COLOR_FORMAT_UYVP = 69,
        NVBUF_COLOR_FORMAT_UYVP_ER = 70,
        NVBUF_COLOR_FORMAT_YUV444_ER = 71,
        NVBUF_COLOR_FORMAT_YUV444_709 = 72,
        NVBUF_COLOR_FORMAT_YUV444_709_ER = 73,
        NVBUF_COLOR_FORMAT_YUV444_2020 = 74,
        NVBUF_COLOR_FORMAT_YUV444_10LE = 75,
        NVBUF_COLOR_FORMAT_YUV444_10LE_ER = 76,
        NVBUF_COLOR_FORMAT_YUV444_10LE_709 = 77,
        NVBUF_COLOR_FORMAT_YUV444_10LE_709_ER = 78,
        NVBUF_COLOR_FORMAT_YUV444_10LE_2020 = 79,
        NVBUF_COLOR_FORMAT_YUV444_12LE = 80,
        NVBUF_COLOR_FORMAT_YUV444_12LE_ER = 81,
        NVBUF_COLOR_FORMAT_YUV444_12LE_709 = 82,
        NVBUF_COLOR_FORMAT_YUV444_12LE_709_ER = 83,
        NVBUF_COLOR_FORMAT_YUV444_12LE_2020 = 84,
        NVBUF_COLOR_FORMAT_NV12_12LE_ER = 85,
        NVBUF_COLOR_FORMAT_NV12_12LE_709 = 86,
        NVBUF_COLOR_FORMAT_NV12_12LE_709_ER = 87,
        NVBUF_COLOR_FORMAT_GRAY8_ER = 88,
        NVBUF_COLOR_FORMAT_UYVY_709 = 89,
        NVBUF_COLOR_FORMAT_UYVY_709_ER = 90,
        NVBUF_COLOR_FORMAT_UYVY_2020 = 91,
        NVBUF_COLOR_FORMAT_GRAY16_LE = 92,
        NVBUF_COLOR_FORMAT_LAST = 93,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum NvBufSurfaceLayout {
        NVBUF_LAYOUT_PITCH = 0,
        NVBUF_LAYOUT_BLOCK_LINEAR = 1,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum NvBufSurfaceMemType {
        NVBUF_MEM_DEFAULT = 0,
        NVBUF_MEM_CUDA_PINNED = 1,
        NVBUF_MEM_CUDA_DEVICE = 2,
        NVBUF_MEM_CUDA_UNIFIED = 3,
        NVBUF_MEM_SURFACE_ARRAY = 4,
        NVBUF_MEM_HANDLE = 5,
        NVBUF_MEM_SYSTEM = 6,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum NvBufSurfaceDisplayScanFormat {
        NVBUF_DISPLAYSCANFORMAT_PROGRESSIVE = 0,
        NVBUF_DISPLAYSCANFORMAT_INTERLACED = 1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfacePlaneParamsEx {
        pub scanformat: [root::NvBufSurfaceDisplayScanFormat; 4usize],
        pub secondfieldoffset: [u32; 4usize],
        pub blockheightlog2: [u32; 4usize],
        pub physicaladdress: [u32; 4usize],
        pub flags: [u64; 4usize],
        pub drmModifier: [u64; 4usize],
        pub _reserved: [*mut ::core::ffi::c_void; 12usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfacePlaneParams {
        pub num_planes: u32,
        pub width: [u32; 4usize],
        pub height: [u32; 4usize],
        pub pitch: [u32; 4usize],
        pub offset: [u32; 4usize],
        pub psize: [u32; 4usize],
        pub bytesPerPix: [u32; 4usize],
        pub _reserved: [*mut ::core::ffi::c_void; 16usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfaceChromaSubsamplingParams {
        pub chromaLocHoriz: u8,
        pub chromaLocVert: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfaceMappedAddr {
        pub addr: [*mut ::core::ffi::c_void; 4usize],
        pub eglImage: *mut ::core::ffi::c_void,
        pub _reserved: [*mut ::core::ffi::c_void; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfaceParamsEx {
        pub startofvaliddata: i32,
        pub sizeofvaliddatainbytes: i32,
        pub chromaSubsampling: root::NvBufSurfaceChromaSubsamplingParams,
        pub is_protected: bool,
        pub planeParamsex: root::NvBufSurfacePlaneParamsEx,
        pub _reserved: [*mut ::core::ffi::c_void; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurfaceParams {
        pub width: u32,
        pub height: u32,
        pub pitch: u32,
        pub colorFormat: root::NvBufSurfaceColorFormat,
        pub layout: root::NvBufSurfaceLayout,
        pub bufferDesc: u64,
        pub dataSize: u32,
        pub dataPtr: *mut ::core::ffi::c_void,
        pub planeParams: root::NvBufSurfacePlaneParams,
        pub mappedAddr: root::NvBufSurfaceMappedAddr,
        pub paramex: *mut root::NvBufSurfaceParamsEx,
        pub _reserved: [*mut ::core::ffi::c_void; 3usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct NvBufSurface {
        pub gpuId: u32,
        pub batchSize: u32,
        pub numFilled: u32,
        pub isContiguous: bool,
        pub memType: root::NvBufSurfaceMemType,
        pub surfaceList: *mut root::NvBufSurfaceParams,
        pub _reserved: [*mut ::core::ffi::c_void; 4usize],
    }
    unsafe extern "C" {
        pub fn NvBufSurfaceDestroy(surf: *mut root::NvBufSurface) -> ::core::ffi::c_int;
        pub fn NvBufSurfaceMap(
            surf: *mut root::NvBufSurface,
            index: ::core::ffi::c_int,
            plane: ::core::ffi::c_int,
            type_: root::NvBufSurfaceMemMapFlags,
        ) -> ::core::ffi::c_int;
        pub fn NvBufSurfaceSyncForCpu(
            surf: *mut root::NvBufSurface,
            index: ::core::ffi::c_int,
            plane: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int;
        pub fn NvBufSurfaceFromFd(
            dmabuf_fd: ::core::ffi::c_int,
            buffer: *mut *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int;
    }
}
