/* automatically generated by rust-bindgen 0.71.1 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[doc = r" If Bindgen could only determine the size and alignment of a"]
    #[doc = r" type, it is represented like this."]
    #[derive(PartialEq, Copy, Clone, Debug, Hash)]
    #[repr(C)]
    pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
    impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
        fn default() -> Self {
            Self([<T as Default>::default(); N])
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Ty> = _Ty;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        pub type conditional_type<_Ty1> = _Ty1;
        pub type conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_Ty1, _Ty2> {
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Ty1>>,
            pub _phantom_1: ::core::marker::PhantomData<::core::cell::UnsafeCell<_Ty2>>,
            pub first: _Ty1,
            pub second: _Ty2,
        }
        pub type pair_first_type<_Ty1> = _Ty1;
        pub type pair_second_type<_Ty2> = _Ty2;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type _Rebind_alloc_t = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator__From_primary = root::std::allocator;
        pub type allocator_value_type<_Ty> = _Ty;
        pub type allocator_pointer<_Ty> = *mut _Ty;
        pub type allocator_const_pointer<_Ty> = *const _Ty;
        pub type allocator_reference<_Ty> = *mut _Ty;
        pub type allocator_const_reference<_Ty> = *const _Ty;
        pub type allocator_size_type = ::core::ffi::c_ulonglong;
        pub type allocator_difference_type = ::core::ffi::c_longlong;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        pub type allocator_is_always_equal = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Container_base0 {
            pub _address: u8,
        }
        pub const _Iterator_base0__Unwrap_when_unverified: bool = true;
        pub type _Container_base = root::std::_Container_base0;
        pub type _Compressed_pair__Mybase<_Ty1> = _Ty1;
        #[repr(C)]
        pub struct _Vector_val {
            pub _Myfirst: root::std::_Vector_val_pointer,
            pub _Mylast: root::std::_Vector_val_pointer,
            pub _Myend: root::std::_Vector_val_pointer,
        }
        pub type _Vector_val_value_type = root::__BindgenOpaqueArray<u8, 0usize>;
        pub type _Vector_val_size_type = root::__BindgenOpaqueArray<u8, 0usize>;
        pub type _Vector_val_difference_type = root::__BindgenOpaqueArray<u8, 0usize>;
        pub type _Vector_val_pointer = root::__BindgenOpaqueArray<u8, 0usize>;
        pub type _Vector_val_const_pointer = root::__BindgenOpaqueArray<u8, 0usize>;
        pub type _Vector_val_reference = *mut root::std::_Vector_val_value_type;
        pub type _Vector_val_const_reference = *const root::std::_Vector_val_value_type;
        impl ::core::fmt::Debug for _Vector_val {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                write!(f, "_Vector_val {{  }}")
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dim3 {
        pub x: ::core::ffi::c_uint,
        pub y: ::core::ffi::c_uint,
        pub z: ::core::ffi::c_uint,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum cudaError {
        cudaSuccess = 0,
        cudaErrorInvalidValue = 1,
        cudaErrorMemoryAllocation = 2,
        cudaErrorInitializationError = 3,
        cudaErrorCudartUnloading = 4,
        cudaErrorProfilerDisabled = 5,
        cudaErrorProfilerNotInitialized = 6,
        cudaErrorProfilerAlreadyStarted = 7,
        cudaErrorProfilerAlreadyStopped = 8,
        cudaErrorInvalidConfiguration = 9,
        cudaErrorInvalidPitchValue = 12,
        cudaErrorInvalidSymbol = 13,
        cudaErrorInvalidHostPointer = 16,
        cudaErrorInvalidDevicePointer = 17,
        cudaErrorInvalidTexture = 18,
        cudaErrorInvalidTextureBinding = 19,
        cudaErrorInvalidChannelDescriptor = 20,
        cudaErrorInvalidMemcpyDirection = 21,
        cudaErrorAddressOfConstant = 22,
        cudaErrorTextureFetchFailed = 23,
        cudaErrorTextureNotBound = 24,
        cudaErrorSynchronizationError = 25,
        cudaErrorInvalidFilterSetting = 26,
        cudaErrorInvalidNormSetting = 27,
        cudaErrorMixedDeviceExecution = 28,
        cudaErrorNotYetImplemented = 31,
        cudaErrorMemoryValueTooLarge = 32,
        cudaErrorStubLibrary = 34,
        cudaErrorInsufficientDriver = 35,
        cudaErrorCallRequiresNewerDriver = 36,
        cudaErrorInvalidSurface = 37,
        cudaErrorDuplicateVariableName = 43,
        cudaErrorDuplicateTextureName = 44,
        cudaErrorDuplicateSurfaceName = 45,
        cudaErrorDevicesUnavailable = 46,
        cudaErrorIncompatibleDriverContext = 49,
        cudaErrorMissingConfiguration = 52,
        cudaErrorPriorLaunchFailure = 53,
        cudaErrorLaunchMaxDepthExceeded = 65,
        cudaErrorLaunchFileScopedTex = 66,
        cudaErrorLaunchFileScopedSurf = 67,
        cudaErrorSyncDepthExceeded = 68,
        cudaErrorLaunchPendingCountExceeded = 69,
        cudaErrorInvalidDeviceFunction = 98,
        cudaErrorNoDevice = 100,
        cudaErrorInvalidDevice = 101,
        cudaErrorDeviceNotLicensed = 102,
        cudaErrorSoftwareValidityNotEstablished = 103,
        cudaErrorStartupFailure = 127,
        cudaErrorInvalidKernelImage = 200,
        cudaErrorDeviceUninitialized = 201,
        cudaErrorMapBufferObjectFailed = 205,
        cudaErrorUnmapBufferObjectFailed = 206,
        cudaErrorArrayIsMapped = 207,
        cudaErrorAlreadyMapped = 208,
        cudaErrorNoKernelImageForDevice = 209,
        cudaErrorAlreadyAcquired = 210,
        cudaErrorNotMapped = 211,
        cudaErrorNotMappedAsArray = 212,
        cudaErrorNotMappedAsPointer = 213,
        cudaErrorECCUncorrectable = 214,
        cudaErrorUnsupportedLimit = 215,
        cudaErrorDeviceAlreadyInUse = 216,
        cudaErrorPeerAccessUnsupported = 217,
        cudaErrorInvalidPtx = 218,
        cudaErrorInvalidGraphicsContext = 219,
        cudaErrorNvlinkUncorrectable = 220,
        cudaErrorJitCompilerNotFound = 221,
        cudaErrorUnsupportedPtxVersion = 222,
        cudaErrorJitCompilationDisabled = 223,
        cudaErrorUnsupportedExecAffinity = 224,
        cudaErrorUnsupportedDevSideSync = 225,
        cudaErrorInvalidSource = 300,
        cudaErrorFileNotFound = 301,
        cudaErrorSharedObjectSymbolNotFound = 302,
        cudaErrorSharedObjectInitFailed = 303,
        cudaErrorOperatingSystem = 304,
        cudaErrorInvalidResourceHandle = 400,
        cudaErrorIllegalState = 401,
        cudaErrorLossyQuery = 402,
        cudaErrorSymbolNotFound = 500,
        cudaErrorNotReady = 600,
        cudaErrorIllegalAddress = 700,
        cudaErrorLaunchOutOfResources = 701,
        cudaErrorLaunchTimeout = 702,
        cudaErrorLaunchIncompatibleTexturing = 703,
        cudaErrorPeerAccessAlreadyEnabled = 704,
        cudaErrorPeerAccessNotEnabled = 705,
        cudaErrorSetOnActiveProcess = 708,
        cudaErrorContextIsDestroyed = 709,
        cudaErrorAssert = 710,
        cudaErrorTooManyPeers = 711,
        cudaErrorHostMemoryAlreadyRegistered = 712,
        cudaErrorHostMemoryNotRegistered = 713,
        cudaErrorHardwareStackError = 714,
        cudaErrorIllegalInstruction = 715,
        cudaErrorMisalignedAddress = 716,
        cudaErrorInvalidAddressSpace = 717,
        cudaErrorInvalidPc = 718,
        cudaErrorLaunchFailure = 719,
        cudaErrorCooperativeLaunchTooLarge = 720,
        cudaErrorNotPermitted = 800,
        cudaErrorNotSupported = 801,
        cudaErrorSystemNotReady = 802,
        cudaErrorSystemDriverMismatch = 803,
        cudaErrorCompatNotSupportedOnDevice = 804,
        cudaErrorMpsConnectionFailed = 805,
        cudaErrorMpsRpcFailure = 806,
        cudaErrorMpsServerNotReady = 807,
        cudaErrorMpsMaxClientsReached = 808,
        cudaErrorMpsMaxConnectionsReached = 809,
        cudaErrorMpsClientTerminated = 810,
        cudaErrorCdpNotSupported = 811,
        cudaErrorCdpVersionMismatch = 812,
        cudaErrorStreamCaptureUnsupported = 900,
        cudaErrorStreamCaptureInvalidated = 901,
        cudaErrorStreamCaptureMerge = 902,
        cudaErrorStreamCaptureUnmatched = 903,
        cudaErrorStreamCaptureUnjoined = 904,
        cudaErrorStreamCaptureIsolation = 905,
        cudaErrorStreamCaptureImplicit = 906,
        cudaErrorCapturedEvent = 907,
        cudaErrorStreamCaptureWrongThread = 908,
        cudaErrorTimeout = 909,
        cudaErrorGraphExecUpdateFailure = 910,
        cudaErrorExternalDevice = 911,
        cudaErrorInvalidClusterSize = 912,
        cudaErrorFunctionNotLoaded = 913,
        cudaErrorInvalidResourceType = 914,
        cudaErrorInvalidResourceConfiguration = 915,
        cudaErrorUnknown = 999,
        cudaErrorApiFailureBase = 10000,
    }
    pub const cudaChannelFormatKind_cudaChannelFormatKindSigned: root::cudaChannelFormatKind = 0;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsigned: root::cudaChannelFormatKind = 1;
    pub const cudaChannelFormatKind_cudaChannelFormatKindFloat: root::cudaChannelFormatKind = 2;
    pub const cudaChannelFormatKind_cudaChannelFormatKindNone: root::cudaChannelFormatKind = 3;
    pub const cudaChannelFormatKind_cudaChannelFormatKindNV12: root::cudaChannelFormatKind = 4;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X1:
        root::cudaChannelFormatKind = 5;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X2:
        root::cudaChannelFormatKind = 6;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized8X4:
        root::cudaChannelFormatKind = 7;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X1:
        root::cudaChannelFormatKind = 8;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X2:
        root::cudaChannelFormatKind = 9;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedNormalized16X4:
        root::cudaChannelFormatKind = 10;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X1:
        root::cudaChannelFormatKind = 11;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X2:
        root::cudaChannelFormatKind = 12;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized8X4:
        root::cudaChannelFormatKind = 13;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X1:
        root::cudaChannelFormatKind = 14;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X2:
        root::cudaChannelFormatKind = 15;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedNormalized16X4:
        root::cudaChannelFormatKind = 16;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1:
        root::cudaChannelFormatKind = 17;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed1SRGB:
        root::cudaChannelFormatKind = 18;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2:
        root::cudaChannelFormatKind = 19;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed2SRGB:
        root::cudaChannelFormatKind = 20;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3:
        root::cudaChannelFormatKind = 21;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed3SRGB:
        root::cudaChannelFormatKind = 22;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed4:
        root::cudaChannelFormatKind = 23;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed4:
        root::cudaChannelFormatKind = 24;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed5:
        root::cudaChannelFormatKind = 25;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed5:
        root::cudaChannelFormatKind = 26;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed6H:
        root::cudaChannelFormatKind = 27;
    pub const cudaChannelFormatKind_cudaChannelFormatKindSignedBlockCompressed6H:
        root::cudaChannelFormatKind = 28;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7:
        root::cudaChannelFormatKind = 29;
    pub const cudaChannelFormatKind_cudaChannelFormatKindUnsignedBlockCompressed7SRGB:
        root::cudaChannelFormatKind = 30;
    pub type cudaChannelFormatKind = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaChannelFormatDesc {
        pub x: ::core::ffi::c_int,
        pub y: ::core::ffi::c_int,
        pub z: ::core::ffi::c_int,
        pub w: ::core::ffi::c_int,
        pub f: root::cudaChannelFormatKind,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaArray {
        _unused: [u8; 0],
    }
    pub type cudaArray_t = *mut root::cudaArray;
    pub type cudaArray_const_t = *const root::cudaArray;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMipmappedArray {
        _unused: [u8; 0],
    }
    pub type cudaMipmappedArray_t = *mut root::cudaMipmappedArray;
    pub type cudaMipmappedArray_const_t = *const root::cudaMipmappedArray;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaArraySparseProperties {
        pub tileExtent: root::cudaArraySparseProperties__bindgen_ty_1,
        pub miptailFirstLevel: ::core::ffi::c_uint,
        pub miptailSize: ::core::ffi::c_ulonglong,
        pub flags: ::core::ffi::c_uint,
        pub reserved: [::core::ffi::c_uint; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaArraySparseProperties__bindgen_ty_1 {
        pub width: ::core::ffi::c_uint,
        pub height: ::core::ffi::c_uint,
        pub depth: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaArrayMemoryRequirements {
        pub size: usize,
        pub alignment: usize,
        pub reserved: [::core::ffi::c_uint; 4usize],
    }
    pub const cudaMemoryType_cudaMemoryTypeUnregistered: root::cudaMemoryType = 0;
    pub const cudaMemoryType_cudaMemoryTypeHost: root::cudaMemoryType = 1;
    pub const cudaMemoryType_cudaMemoryTypeDevice: root::cudaMemoryType = 2;
    pub const cudaMemoryType_cudaMemoryTypeManaged: root::cudaMemoryType = 3;
    pub type cudaMemoryType = ::core::ffi::c_int;
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum cudaMemcpyKind {
        cudaMemcpyHostToHost = 0,
        cudaMemcpyHostToDevice = 1,
        cudaMemcpyDeviceToHost = 2,
        cudaMemcpyDeviceToDevice = 3,
        cudaMemcpyDefault = 4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaPitchedPtr {
        pub ptr: *mut ::core::ffi::c_void,
        pub pitch: usize,
        pub xsize: usize,
        pub ysize: usize,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExtent {
        pub width: usize,
        pub height: usize,
        pub depth: usize,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaPos {
        pub x: usize,
        pub y: usize,
        pub z: usize,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemcpy3DParms {
        pub srcArray: root::cudaArray_t,
        pub srcPos: root::cudaPos,
        pub srcPtr: root::cudaPitchedPtr,
        pub dstArray: root::cudaArray_t,
        pub dstPos: root::cudaPos,
        pub dstPtr: root::cudaPitchedPtr,
        pub extent: root::cudaExtent,
        pub kind: root::cudaMemcpyKind,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemcpyNodeParams {
        pub flags: ::core::ffi::c_int,
        pub reserved: [::core::ffi::c_int; 3usize],
        pub copyParams: root::cudaMemcpy3DParms,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemcpy3DPeerParms {
        pub srcArray: root::cudaArray_t,
        pub srcPos: root::cudaPos,
        pub srcPtr: root::cudaPitchedPtr,
        pub srcDevice: ::core::ffi::c_int,
        pub dstArray: root::cudaArray_t,
        pub dstPos: root::cudaPos,
        pub dstPtr: root::cudaPitchedPtr,
        pub dstDevice: ::core::ffi::c_int,
        pub extent: root::cudaExtent,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemsetParams {
        pub dst: *mut ::core::ffi::c_void,
        pub pitch: usize,
        pub value: ::core::ffi::c_uint,
        pub elementSize: ::core::ffi::c_uint,
        pub width: usize,
        pub height: usize,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemsetParamsV2 {
        pub dst: *mut ::core::ffi::c_void,
        pub pitch: usize,
        pub value: ::core::ffi::c_uint,
        pub elementSize: ::core::ffi::c_uint,
        pub width: usize,
        pub height: usize,
    }
    pub const cudaAccessProperty_cudaAccessPropertyNormal: root::cudaAccessProperty = 0;
    pub const cudaAccessProperty_cudaAccessPropertyStreaming: root::cudaAccessProperty = 1;
    pub const cudaAccessProperty_cudaAccessPropertyPersisting: root::cudaAccessProperty = 2;
    pub type cudaAccessProperty = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaAccessPolicyWindow {
        pub base_ptr: *mut ::core::ffi::c_void,
        pub num_bytes: usize,
        pub hitRatio: f32,
        pub hitProp: root::cudaAccessProperty,
        pub missProp: root::cudaAccessProperty,
    }
    pub type cudaHostFn_t =
        ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaHostNodeParams {
        pub fn_: root::cudaHostFn_t,
        pub userData: *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaHostNodeParamsV2 {
        pub fn_: root::cudaHostFn_t,
        pub userData: *mut ::core::ffi::c_void,
    }
    pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusNone: root::cudaStreamCaptureStatus =
        0;
    pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusActive: root::cudaStreamCaptureStatus =
        1;
    pub const cudaStreamCaptureStatus_cudaStreamCaptureStatusInvalidated:
        root::cudaStreamCaptureStatus = 2;
    pub type cudaStreamCaptureStatus = ::core::ffi::c_int;
    pub const cudaStreamCaptureMode_cudaStreamCaptureModeGlobal: root::cudaStreamCaptureMode = 0;
    pub const cudaStreamCaptureMode_cudaStreamCaptureModeThreadLocal: root::cudaStreamCaptureMode =
        1;
    pub const cudaStreamCaptureMode_cudaStreamCaptureModeRelaxed: root::cudaStreamCaptureMode = 2;
    pub type cudaStreamCaptureMode = ::core::ffi::c_int;
    pub const cudaSynchronizationPolicy_cudaSyncPolicyAuto: root::cudaSynchronizationPolicy = 1;
    pub const cudaSynchronizationPolicy_cudaSyncPolicySpin: root::cudaSynchronizationPolicy = 2;
    pub const cudaSynchronizationPolicy_cudaSyncPolicyYield: root::cudaSynchronizationPolicy = 3;
    pub const cudaSynchronizationPolicy_cudaSyncPolicyBlockingSync:
        root::cudaSynchronizationPolicy = 4;
    pub type cudaSynchronizationPolicy = ::core::ffi::c_int;
    pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicyDefault:
        root::cudaClusterSchedulingPolicy = 0;
    pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicySpread:
        root::cudaClusterSchedulingPolicy = 1;
    pub const cudaClusterSchedulingPolicy_cudaClusterSchedulingPolicyLoadBalancing:
        root::cudaClusterSchedulingPolicy = 2;
    pub type cudaClusterSchedulingPolicy = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaGraphicsResource {
        _unused: [u8; 0],
    }
    pub const cudaResourceType_cudaResourceTypeArray: root::cudaResourceType = 0;
    pub const cudaResourceType_cudaResourceTypeMipmappedArray: root::cudaResourceType = 1;
    pub const cudaResourceType_cudaResourceTypeLinear: root::cudaResourceType = 2;
    pub const cudaResourceType_cudaResourceTypePitch2D: root::cudaResourceType = 3;
    pub type cudaResourceType = ::core::ffi::c_int;
    pub const cudaResourceViewFormat_cudaResViewFormatNone: root::cudaResourceViewFormat = 0;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar1: root::cudaResourceViewFormat =
        1;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar2: root::cudaResourceViewFormat =
        2;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedChar4: root::cudaResourceViewFormat =
        3;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedChar1: root::cudaResourceViewFormat = 4;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedChar2: root::cudaResourceViewFormat = 5;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedChar4: root::cudaResourceViewFormat = 6;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort1: root::cudaResourceViewFormat =
        7;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort2: root::cudaResourceViewFormat =
        8;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedShort4: root::cudaResourceViewFormat =
        9;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedShort1: root::cudaResourceViewFormat =
        10;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedShort2: root::cudaResourceViewFormat =
        11;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedShort4: root::cudaResourceViewFormat =
        12;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt1: root::cudaResourceViewFormat =
        13;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt2: root::cudaResourceViewFormat =
        14;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedInt4: root::cudaResourceViewFormat =
        15;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedInt1: root::cudaResourceViewFormat = 16;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedInt2: root::cudaResourceViewFormat = 17;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedInt4: root::cudaResourceViewFormat = 18;
    pub const cudaResourceViewFormat_cudaResViewFormatHalf1: root::cudaResourceViewFormat = 19;
    pub const cudaResourceViewFormat_cudaResViewFormatHalf2: root::cudaResourceViewFormat = 20;
    pub const cudaResourceViewFormat_cudaResViewFormatHalf4: root::cudaResourceViewFormat = 21;
    pub const cudaResourceViewFormat_cudaResViewFormatFloat1: root::cudaResourceViewFormat = 22;
    pub const cudaResourceViewFormat_cudaResViewFormatFloat2: root::cudaResourceViewFormat = 23;
    pub const cudaResourceViewFormat_cudaResViewFormatFloat4: root::cudaResourceViewFormat = 24;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed1:
        root::cudaResourceViewFormat = 25;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed2:
        root::cudaResourceViewFormat = 26;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed3:
        root::cudaResourceViewFormat = 27;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed4:
        root::cudaResourceViewFormat = 28;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed4:
        root::cudaResourceViewFormat = 29;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed5:
        root::cudaResourceViewFormat = 30;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed5:
        root::cudaResourceViewFormat = 31;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed6H:
        root::cudaResourceViewFormat = 32;
    pub const cudaResourceViewFormat_cudaResViewFormatSignedBlockCompressed6H:
        root::cudaResourceViewFormat = 33;
    pub const cudaResourceViewFormat_cudaResViewFormatUnsignedBlockCompressed7:
        root::cudaResourceViewFormat = 34;
    pub type cudaResourceViewFormat = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaResourceDesc {
        pub resType: root::cudaResourceType,
        pub res: root::cudaResourceDesc__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaResourceDesc__bindgen_ty_1 {
        pub array: root::cudaResourceDesc__bindgen_ty_1__bindgen_ty_1,
        pub mipmap: root::cudaResourceDesc__bindgen_ty_1__bindgen_ty_2,
        pub linear: root::cudaResourceDesc__bindgen_ty_1__bindgen_ty_3,
        pub pitch2D: root::cudaResourceDesc__bindgen_ty_1__bindgen_ty_4,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_1 {
        pub array: root::cudaArray_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_2 {
        pub mipmap: root::cudaMipmappedArray_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_3 {
        pub devPtr: *mut ::core::ffi::c_void,
        pub desc: root::cudaChannelFormatDesc,
        pub sizeInBytes: usize,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaResourceDesc__bindgen_ty_1__bindgen_ty_4 {
        pub devPtr: *mut ::core::ffi::c_void,
        pub desc: root::cudaChannelFormatDesc,
        pub width: usize,
        pub height: usize,
        pub pitchInBytes: usize,
    }
    impl ::core::fmt::Debug for cudaResourceDesc__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "cudaResourceDesc__bindgen_ty_1 {{ union }}")
        }
    }
    impl ::core::fmt::Debug for cudaResourceDesc {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaResourceDesc {{ resType: {:?}, res: {:?} }}",
                self.resType, self.res
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaResourceViewDesc {
        pub format: root::cudaResourceViewFormat,
        pub width: usize,
        pub height: usize,
        pub depth: usize,
        pub firstMipmapLevel: ::core::ffi::c_uint,
        pub lastMipmapLevel: ::core::ffi::c_uint,
        pub firstLayer: ::core::ffi::c_uint,
        pub lastLayer: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaPointerAttributes {
        pub type_: root::cudaMemoryType,
        pub device: ::core::ffi::c_int,
        pub devicePointer: *mut ::core::ffi::c_void,
        pub hostPointer: *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaFuncAttributes {
        pub sharedSizeBytes: usize,
        pub constSizeBytes: usize,
        pub localSizeBytes: usize,
        pub maxThreadsPerBlock: ::core::ffi::c_int,
        pub numRegs: ::core::ffi::c_int,
        pub ptxVersion: ::core::ffi::c_int,
        pub binaryVersion: ::core::ffi::c_int,
        pub cacheModeCA: ::core::ffi::c_int,
        pub maxDynamicSharedSizeBytes: ::core::ffi::c_int,
        pub preferredShmemCarveout: ::core::ffi::c_int,
        pub clusterDimMustBeSet: ::core::ffi::c_int,
        pub requiredClusterWidth: ::core::ffi::c_int,
        pub requiredClusterHeight: ::core::ffi::c_int,
        pub requiredClusterDepth: ::core::ffi::c_int,
        pub clusterSchedulingPolicyPreference: ::core::ffi::c_int,
        pub nonPortableClusterSizeAllowed: ::core::ffi::c_int,
        pub reserved: [::core::ffi::c_int; 16usize],
    }
    pub const cudaFuncAttribute_cudaFuncAttributeMaxDynamicSharedMemorySize:
        root::cudaFuncAttribute = 8;
    pub const cudaFuncAttribute_cudaFuncAttributePreferredSharedMemoryCarveout:
        root::cudaFuncAttribute = 9;
    pub const cudaFuncAttribute_cudaFuncAttributeClusterDimMustBeSet: root::cudaFuncAttribute = 10;
    pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterWidth: root::cudaFuncAttribute = 11;
    pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterHeight: root::cudaFuncAttribute =
        12;
    pub const cudaFuncAttribute_cudaFuncAttributeRequiredClusterDepth: root::cudaFuncAttribute = 13;
    pub const cudaFuncAttribute_cudaFuncAttributeNonPortableClusterSizeAllowed:
        root::cudaFuncAttribute = 14;
    pub const cudaFuncAttribute_cudaFuncAttributeClusterSchedulingPolicyPreference:
        root::cudaFuncAttribute = 15;
    pub const cudaFuncAttribute_cudaFuncAttributeMax: root::cudaFuncAttribute = 16;
    pub type cudaFuncAttribute = ::core::ffi::c_int;
    pub const cudaFuncCache_cudaFuncCachePreferNone: root::cudaFuncCache = 0;
    pub const cudaFuncCache_cudaFuncCachePreferShared: root::cudaFuncCache = 1;
    pub const cudaFuncCache_cudaFuncCachePreferL1: root::cudaFuncCache = 2;
    pub const cudaFuncCache_cudaFuncCachePreferEqual: root::cudaFuncCache = 3;
    pub type cudaFuncCache = ::core::ffi::c_int;
    pub const cudaSharedMemConfig_cudaSharedMemBankSizeDefault: root::cudaSharedMemConfig = 0;
    pub const cudaSharedMemConfig_cudaSharedMemBankSizeFourByte: root::cudaSharedMemConfig = 1;
    pub const cudaSharedMemConfig_cudaSharedMemBankSizeEightByte: root::cudaSharedMemConfig = 2;
    pub type cudaSharedMemConfig = ::core::ffi::c_int;
    pub const cudaLimit_cudaLimitStackSize: root::cudaLimit = 0;
    pub const cudaLimit_cudaLimitPrintfFifoSize: root::cudaLimit = 1;
    pub const cudaLimit_cudaLimitMallocHeapSize: root::cudaLimit = 2;
    pub const cudaLimit_cudaLimitDevRuntimeSyncDepth: root::cudaLimit = 3;
    pub const cudaLimit_cudaLimitDevRuntimePendingLaunchCount: root::cudaLimit = 4;
    pub const cudaLimit_cudaLimitMaxL2FetchGranularity: root::cudaLimit = 5;
    pub const cudaLimit_cudaLimitPersistingL2CacheSize: root::cudaLimit = 6;
    pub type cudaLimit = ::core::ffi::c_int;
    pub const cudaMemoryAdvise_cudaMemAdviseSetReadMostly: root::cudaMemoryAdvise = 1;
    pub const cudaMemoryAdvise_cudaMemAdviseUnsetReadMostly: root::cudaMemoryAdvise = 2;
    pub const cudaMemoryAdvise_cudaMemAdviseSetPreferredLocation: root::cudaMemoryAdvise = 3;
    pub const cudaMemoryAdvise_cudaMemAdviseUnsetPreferredLocation: root::cudaMemoryAdvise = 4;
    pub const cudaMemoryAdvise_cudaMemAdviseSetAccessedBy: root::cudaMemoryAdvise = 5;
    pub const cudaMemoryAdvise_cudaMemAdviseUnsetAccessedBy: root::cudaMemoryAdvise = 6;
    pub type cudaMemoryAdvise = ::core::ffi::c_int;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributeReadMostly: root::cudaMemRangeAttribute =
        1;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocation:
        root::cudaMemRangeAttribute = 2;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributeAccessedBy: root::cudaMemRangeAttribute =
        3;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocation:
        root::cudaMemRangeAttribute = 4;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocationType:
        root::cudaMemRangeAttribute = 5;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributePreferredLocationId:
        root::cudaMemRangeAttribute = 6;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocationType:
        root::cudaMemRangeAttribute = 7;
    pub const cudaMemRangeAttribute_cudaMemRangeAttributeLastPrefetchLocationId:
        root::cudaMemRangeAttribute = 8;
    pub type cudaMemRangeAttribute = ::core::ffi::c_int;
    pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToOwner:
        root::cudaFlushGPUDirectRDMAWritesScope = 100;
    pub const cudaFlushGPUDirectRDMAWritesScope_cudaFlushGPUDirectRDMAWritesToAllDevices:
        root::cudaFlushGPUDirectRDMAWritesScope = 200;
    pub type cudaFlushGPUDirectRDMAWritesScope = ::core::ffi::c_int;
    pub const cudaFlushGPUDirectRDMAWritesTarget_cudaFlushGPUDirectRDMAWritesTargetCurrentDevice:
        root::cudaFlushGPUDirectRDMAWritesTarget = 0;
    pub type cudaFlushGPUDirectRDMAWritesTarget = ::core::ffi::c_int;
    pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerBlock: root::cudaDeviceAttr = 1;
    pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimX: root::cudaDeviceAttr = 2;
    pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimY: root::cudaDeviceAttr = 3;
    pub const cudaDeviceAttr_cudaDevAttrMaxBlockDimZ: root::cudaDeviceAttr = 4;
    pub const cudaDeviceAttr_cudaDevAttrMaxGridDimX: root::cudaDeviceAttr = 5;
    pub const cudaDeviceAttr_cudaDevAttrMaxGridDimY: root::cudaDeviceAttr = 6;
    pub const cudaDeviceAttr_cudaDevAttrMaxGridDimZ: root::cudaDeviceAttr = 7;
    pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlock: root::cudaDeviceAttr = 8;
    pub const cudaDeviceAttr_cudaDevAttrTotalConstantMemory: root::cudaDeviceAttr = 9;
    pub const cudaDeviceAttr_cudaDevAttrWarpSize: root::cudaDeviceAttr = 10;
    pub const cudaDeviceAttr_cudaDevAttrMaxPitch: root::cudaDeviceAttr = 11;
    pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerBlock: root::cudaDeviceAttr = 12;
    pub const cudaDeviceAttr_cudaDevAttrClockRate: root::cudaDeviceAttr = 13;
    pub const cudaDeviceAttr_cudaDevAttrTextureAlignment: root::cudaDeviceAttr = 14;
    pub const cudaDeviceAttr_cudaDevAttrGpuOverlap: root::cudaDeviceAttr = 15;
    pub const cudaDeviceAttr_cudaDevAttrMultiProcessorCount: root::cudaDeviceAttr = 16;
    pub const cudaDeviceAttr_cudaDevAttrKernelExecTimeout: root::cudaDeviceAttr = 17;
    pub const cudaDeviceAttr_cudaDevAttrIntegrated: root::cudaDeviceAttr = 18;
    pub const cudaDeviceAttr_cudaDevAttrCanMapHostMemory: root::cudaDeviceAttr = 19;
    pub const cudaDeviceAttr_cudaDevAttrComputeMode: root::cudaDeviceAttr = 20;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DWidth: root::cudaDeviceAttr = 21;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DWidth: root::cudaDeviceAttr = 22;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DHeight: root::cudaDeviceAttr = 23;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidth: root::cudaDeviceAttr = 24;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeight: root::cudaDeviceAttr = 25;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepth: root::cudaDeviceAttr = 26;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredWidth: root::cudaDeviceAttr = 27;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredHeight: root::cudaDeviceAttr = 28;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLayeredLayers: root::cudaDeviceAttr = 29;
    pub const cudaDeviceAttr_cudaDevAttrSurfaceAlignment: root::cudaDeviceAttr = 30;
    pub const cudaDeviceAttr_cudaDevAttrConcurrentKernels: root::cudaDeviceAttr = 31;
    pub const cudaDeviceAttr_cudaDevAttrEccEnabled: root::cudaDeviceAttr = 32;
    pub const cudaDeviceAttr_cudaDevAttrPciBusId: root::cudaDeviceAttr = 33;
    pub const cudaDeviceAttr_cudaDevAttrPciDeviceId: root::cudaDeviceAttr = 34;
    pub const cudaDeviceAttr_cudaDevAttrTccDriver: root::cudaDeviceAttr = 35;
    pub const cudaDeviceAttr_cudaDevAttrMemoryClockRate: root::cudaDeviceAttr = 36;
    pub const cudaDeviceAttr_cudaDevAttrGlobalMemoryBusWidth: root::cudaDeviceAttr = 37;
    pub const cudaDeviceAttr_cudaDevAttrL2CacheSize: root::cudaDeviceAttr = 38;
    pub const cudaDeviceAttr_cudaDevAttrMaxThreadsPerMultiProcessor: root::cudaDeviceAttr = 39;
    pub const cudaDeviceAttr_cudaDevAttrAsyncEngineCount: root::cudaDeviceAttr = 40;
    pub const cudaDeviceAttr_cudaDevAttrUnifiedAddressing: root::cudaDeviceAttr = 41;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredWidth: root::cudaDeviceAttr = 42;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLayeredLayers: root::cudaDeviceAttr = 43;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherWidth: root::cudaDeviceAttr = 45;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DGatherHeight: root::cudaDeviceAttr = 46;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DWidthAlt: root::cudaDeviceAttr = 47;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DHeightAlt: root::cudaDeviceAttr = 48;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture3DDepthAlt: root::cudaDeviceAttr = 49;
    pub const cudaDeviceAttr_cudaDevAttrPciDomainId: root::cudaDeviceAttr = 50;
    pub const cudaDeviceAttr_cudaDevAttrTexturePitchAlignment: root::cudaDeviceAttr = 51;
    pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapWidth: root::cudaDeviceAttr = 52;
    pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredWidth: root::cudaDeviceAttr = 53;
    pub const cudaDeviceAttr_cudaDevAttrMaxTextureCubemapLayeredLayers: root::cudaDeviceAttr = 54;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DWidth: root::cudaDeviceAttr = 55;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DWidth: root::cudaDeviceAttr = 56;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DHeight: root::cudaDeviceAttr = 57;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DWidth: root::cudaDeviceAttr = 58;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DHeight: root::cudaDeviceAttr = 59;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface3DDepth: root::cudaDeviceAttr = 60;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredWidth: root::cudaDeviceAttr = 61;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface1DLayeredLayers: root::cudaDeviceAttr = 62;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredWidth: root::cudaDeviceAttr = 63;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredHeight: root::cudaDeviceAttr = 64;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurface2DLayeredLayers: root::cudaDeviceAttr = 65;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapWidth: root::cudaDeviceAttr = 66;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredWidth: root::cudaDeviceAttr = 67;
    pub const cudaDeviceAttr_cudaDevAttrMaxSurfaceCubemapLayeredLayers: root::cudaDeviceAttr = 68;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DLinearWidth: root::cudaDeviceAttr = 69;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearWidth: root::cudaDeviceAttr = 70;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearHeight: root::cudaDeviceAttr = 71;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DLinearPitch: root::cudaDeviceAttr = 72;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedWidth: root::cudaDeviceAttr = 73;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture2DMipmappedHeight: root::cudaDeviceAttr = 74;
    pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMajor: root::cudaDeviceAttr = 75;
    pub const cudaDeviceAttr_cudaDevAttrComputeCapabilityMinor: root::cudaDeviceAttr = 76;
    pub const cudaDeviceAttr_cudaDevAttrMaxTexture1DMipmappedWidth: root::cudaDeviceAttr = 77;
    pub const cudaDeviceAttr_cudaDevAttrStreamPrioritiesSupported: root::cudaDeviceAttr = 78;
    pub const cudaDeviceAttr_cudaDevAttrGlobalL1CacheSupported: root::cudaDeviceAttr = 79;
    pub const cudaDeviceAttr_cudaDevAttrLocalL1CacheSupported: root::cudaDeviceAttr = 80;
    pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerMultiprocessor: root::cudaDeviceAttr = 81;
    pub const cudaDeviceAttr_cudaDevAttrMaxRegistersPerMultiprocessor: root::cudaDeviceAttr = 82;
    pub const cudaDeviceAttr_cudaDevAttrManagedMemory: root::cudaDeviceAttr = 83;
    pub const cudaDeviceAttr_cudaDevAttrIsMultiGpuBoard: root::cudaDeviceAttr = 84;
    pub const cudaDeviceAttr_cudaDevAttrMultiGpuBoardGroupID: root::cudaDeviceAttr = 85;
    pub const cudaDeviceAttr_cudaDevAttrHostNativeAtomicSupported: root::cudaDeviceAttr = 86;
    pub const cudaDeviceAttr_cudaDevAttrSingleToDoublePrecisionPerfRatio: root::cudaDeviceAttr = 87;
    pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccess: root::cudaDeviceAttr = 88;
    pub const cudaDeviceAttr_cudaDevAttrConcurrentManagedAccess: root::cudaDeviceAttr = 89;
    pub const cudaDeviceAttr_cudaDevAttrComputePreemptionSupported: root::cudaDeviceAttr = 90;
    pub const cudaDeviceAttr_cudaDevAttrCanUseHostPointerForRegisteredMem: root::cudaDeviceAttr =
        91;
    pub const cudaDeviceAttr_cudaDevAttrReserved92: root::cudaDeviceAttr = 92;
    pub const cudaDeviceAttr_cudaDevAttrReserved93: root::cudaDeviceAttr = 93;
    pub const cudaDeviceAttr_cudaDevAttrReserved94: root::cudaDeviceAttr = 94;
    pub const cudaDeviceAttr_cudaDevAttrCooperativeLaunch: root::cudaDeviceAttr = 95;
    pub const cudaDeviceAttr_cudaDevAttrCooperativeMultiDeviceLaunch: root::cudaDeviceAttr = 96;
    pub const cudaDeviceAttr_cudaDevAttrMaxSharedMemoryPerBlockOptin: root::cudaDeviceAttr = 97;
    pub const cudaDeviceAttr_cudaDevAttrCanFlushRemoteWrites: root::cudaDeviceAttr = 98;
    pub const cudaDeviceAttr_cudaDevAttrHostRegisterSupported: root::cudaDeviceAttr = 99;
    pub const cudaDeviceAttr_cudaDevAttrPageableMemoryAccessUsesHostPageTables:
        root::cudaDeviceAttr = 100;
    pub const cudaDeviceAttr_cudaDevAttrDirectManagedMemAccessFromHost: root::cudaDeviceAttr = 101;
    pub const cudaDeviceAttr_cudaDevAttrMaxBlocksPerMultiprocessor: root::cudaDeviceAttr = 106;
    pub const cudaDeviceAttr_cudaDevAttrMaxPersistingL2CacheSize: root::cudaDeviceAttr = 108;
    pub const cudaDeviceAttr_cudaDevAttrMaxAccessPolicyWindowSize: root::cudaDeviceAttr = 109;
    pub const cudaDeviceAttr_cudaDevAttrReservedSharedMemoryPerBlock: root::cudaDeviceAttr = 111;
    pub const cudaDeviceAttr_cudaDevAttrSparseCudaArraySupported: root::cudaDeviceAttr = 112;
    pub const cudaDeviceAttr_cudaDevAttrHostRegisterReadOnlySupported: root::cudaDeviceAttr = 113;
    pub const cudaDeviceAttr_cudaDevAttrTimelineSemaphoreInteropSupported: root::cudaDeviceAttr =
        114;
    pub const cudaDeviceAttr_cudaDevAttrMaxTimelineSemaphoreInteropSupported: root::cudaDeviceAttr =
        114;
    pub const cudaDeviceAttr_cudaDevAttrMemoryPoolsSupported: root::cudaDeviceAttr = 115;
    pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMASupported: root::cudaDeviceAttr = 116;
    pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAFlushWritesOptions: root::cudaDeviceAttr = 117;
    pub const cudaDeviceAttr_cudaDevAttrGPUDirectRDMAWritesOrdering: root::cudaDeviceAttr = 118;
    pub const cudaDeviceAttr_cudaDevAttrMemoryPoolSupportedHandleTypes: root::cudaDeviceAttr = 119;
    pub const cudaDeviceAttr_cudaDevAttrClusterLaunch: root::cudaDeviceAttr = 120;
    pub const cudaDeviceAttr_cudaDevAttrDeferredMappingCudaArraySupported: root::cudaDeviceAttr =
        121;
    pub const cudaDeviceAttr_cudaDevAttrReserved122: root::cudaDeviceAttr = 122;
    pub const cudaDeviceAttr_cudaDevAttrReserved123: root::cudaDeviceAttr = 123;
    pub const cudaDeviceAttr_cudaDevAttrReserved124: root::cudaDeviceAttr = 124;
    pub const cudaDeviceAttr_cudaDevAttrIpcEventSupport: root::cudaDeviceAttr = 125;
    pub const cudaDeviceAttr_cudaDevAttrMemSyncDomainCount: root::cudaDeviceAttr = 126;
    pub const cudaDeviceAttr_cudaDevAttrReserved127: root::cudaDeviceAttr = 127;
    pub const cudaDeviceAttr_cudaDevAttrReserved128: root::cudaDeviceAttr = 128;
    pub const cudaDeviceAttr_cudaDevAttrReserved129: root::cudaDeviceAttr = 129;
    pub const cudaDeviceAttr_cudaDevAttrNumaConfig: root::cudaDeviceAttr = 130;
    pub const cudaDeviceAttr_cudaDevAttrNumaId: root::cudaDeviceAttr = 131;
    pub const cudaDeviceAttr_cudaDevAttrReserved132: root::cudaDeviceAttr = 132;
    pub const cudaDeviceAttr_cudaDevAttrMpsEnabled: root::cudaDeviceAttr = 133;
    pub const cudaDeviceAttr_cudaDevAttrHostNumaId: root::cudaDeviceAttr = 134;
    pub const cudaDeviceAttr_cudaDevAttrD3D12CigSupported: root::cudaDeviceAttr = 135;
    pub const cudaDeviceAttr_cudaDevAttrMax: root::cudaDeviceAttr = 136;
    pub type cudaDeviceAttr = ::core::ffi::c_int;
    pub const cudaMemPoolAttr_cudaMemPoolReuseFollowEventDependencies: root::cudaMemPoolAttr = 1;
    pub const cudaMemPoolAttr_cudaMemPoolReuseAllowOpportunistic: root::cudaMemPoolAttr = 2;
    pub const cudaMemPoolAttr_cudaMemPoolReuseAllowInternalDependencies: root::cudaMemPoolAttr = 3;
    pub const cudaMemPoolAttr_cudaMemPoolAttrReleaseThreshold: root::cudaMemPoolAttr = 4;
    pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemCurrent: root::cudaMemPoolAttr = 5;
    pub const cudaMemPoolAttr_cudaMemPoolAttrReservedMemHigh: root::cudaMemPoolAttr = 6;
    pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemCurrent: root::cudaMemPoolAttr = 7;
    pub const cudaMemPoolAttr_cudaMemPoolAttrUsedMemHigh: root::cudaMemPoolAttr = 8;
    pub type cudaMemPoolAttr = ::core::ffi::c_int;
    pub const cudaMemLocationType_cudaMemLocationTypeInvalid: root::cudaMemLocationType = 0;
    pub const cudaMemLocationType_cudaMemLocationTypeDevice: root::cudaMemLocationType = 1;
    pub const cudaMemLocationType_cudaMemLocationTypeHost: root::cudaMemLocationType = 2;
    pub const cudaMemLocationType_cudaMemLocationTypeHostNuma: root::cudaMemLocationType = 3;
    pub const cudaMemLocationType_cudaMemLocationTypeHostNumaCurrent: root::cudaMemLocationType = 4;
    pub type cudaMemLocationType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemLocation {
        pub type_: root::cudaMemLocationType,
        pub id: ::core::ffi::c_int,
    }
    pub const cudaMemAccessFlags_cudaMemAccessFlagsProtNone: root::cudaMemAccessFlags = 0;
    pub const cudaMemAccessFlags_cudaMemAccessFlagsProtRead: root::cudaMemAccessFlags = 1;
    pub const cudaMemAccessFlags_cudaMemAccessFlagsProtReadWrite: root::cudaMemAccessFlags = 3;
    pub type cudaMemAccessFlags = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemAccessDesc {
        pub location: root::cudaMemLocation,
        pub flags: root::cudaMemAccessFlags,
    }
    pub const cudaMemAllocationType_cudaMemAllocationTypeInvalid: root::cudaMemAllocationType = 0;
    pub const cudaMemAllocationType_cudaMemAllocationTypePinned: root::cudaMemAllocationType = 1;
    pub const cudaMemAllocationType_cudaMemAllocationTypeMax: root::cudaMemAllocationType =
        2147483647;
    pub type cudaMemAllocationType = ::core::ffi::c_int;
    pub const cudaMemAllocationHandleType_cudaMemHandleTypeNone: root::cudaMemAllocationHandleType =
        0;
    pub const cudaMemAllocationHandleType_cudaMemHandleTypePosixFileDescriptor:
        root::cudaMemAllocationHandleType = 1;
    pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32:
        root::cudaMemAllocationHandleType = 2;
    pub const cudaMemAllocationHandleType_cudaMemHandleTypeWin32Kmt:
        root::cudaMemAllocationHandleType = 4;
    pub const cudaMemAllocationHandleType_cudaMemHandleTypeFabric:
        root::cudaMemAllocationHandleType = 8;
    pub type cudaMemAllocationHandleType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemPoolProps {
        pub allocType: root::cudaMemAllocationType,
        pub handleTypes: root::cudaMemAllocationHandleType,
        pub location: root::cudaMemLocation,
        pub win32SecurityAttributes: *mut ::core::ffi::c_void,
        pub maxSize: usize,
        pub usage: ::core::ffi::c_ushort,
        pub reserved: [::core::ffi::c_uchar; 54usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemPoolPtrExportData {
        pub reserved: [::core::ffi::c_uchar; 64usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemAllocNodeParams {
        pub poolProps: root::cudaMemPoolProps,
        pub accessDescs: *const root::cudaMemAccessDesc,
        pub accessDescCount: usize,
        pub bytesize: usize,
        pub dptr: *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemAllocNodeParamsV2 {
        pub poolProps: root::cudaMemPoolProps,
        pub accessDescs: *const root::cudaMemAccessDesc,
        pub accessDescCount: usize,
        pub bytesize: usize,
        pub dptr: *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaMemFreeNodeParams {
        pub dptr: *mut ::core::ffi::c_void,
    }
    pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemCurrent:
        root::cudaGraphMemAttributeType = 0;
    pub const cudaGraphMemAttributeType_cudaGraphMemAttrUsedMemHigh:
        root::cudaGraphMemAttributeType = 1;
    pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemCurrent:
        root::cudaGraphMemAttributeType = 2;
    pub const cudaGraphMemAttributeType_cudaGraphMemAttrReservedMemHigh:
        root::cudaGraphMemAttributeType = 3;
    pub type cudaGraphMemAttributeType = ::core::ffi::c_int;
    pub const cudaDeviceP2PAttr_cudaDevP2PAttrPerformanceRank: root::cudaDeviceP2PAttr = 1;
    pub const cudaDeviceP2PAttr_cudaDevP2PAttrAccessSupported: root::cudaDeviceP2PAttr = 2;
    pub const cudaDeviceP2PAttr_cudaDevP2PAttrNativeAtomicSupported: root::cudaDeviceP2PAttr = 3;
    pub const cudaDeviceP2PAttr_cudaDevP2PAttrCudaArrayAccessSupported: root::cudaDeviceP2PAttr = 4;
    pub type cudaDeviceP2PAttr = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUuuid_st {
        pub bytes: [::core::ffi::c_char; 16usize],
    }
    pub type cudaUUID_t = root::CUuuid_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaDeviceProp {
        pub name: [::core::ffi::c_char; 256usize],
        pub uuid: root::cudaUUID_t,
        pub luid: [::core::ffi::c_char; 8usize],
        pub luidDeviceNodeMask: ::core::ffi::c_uint,
        pub totalGlobalMem: usize,
        pub sharedMemPerBlock: usize,
        pub regsPerBlock: ::core::ffi::c_int,
        pub warpSize: ::core::ffi::c_int,
        pub memPitch: usize,
        pub maxThreadsPerBlock: ::core::ffi::c_int,
        pub maxThreadsDim: [::core::ffi::c_int; 3usize],
        pub maxGridSize: [::core::ffi::c_int; 3usize],
        pub clockRate: ::core::ffi::c_int,
        pub totalConstMem: usize,
        pub major: ::core::ffi::c_int,
        pub minor: ::core::ffi::c_int,
        pub textureAlignment: usize,
        pub texturePitchAlignment: usize,
        pub deviceOverlap: ::core::ffi::c_int,
        pub multiProcessorCount: ::core::ffi::c_int,
        pub kernelExecTimeoutEnabled: ::core::ffi::c_int,
        pub integrated: ::core::ffi::c_int,
        pub canMapHostMemory: ::core::ffi::c_int,
        pub computeMode: ::core::ffi::c_int,
        pub maxTexture1D: ::core::ffi::c_int,
        pub maxTexture1DMipmap: ::core::ffi::c_int,
        pub maxTexture1DLinear: ::core::ffi::c_int,
        pub maxTexture2D: [::core::ffi::c_int; 2usize],
        pub maxTexture2DMipmap: [::core::ffi::c_int; 2usize],
        pub maxTexture2DLinear: [::core::ffi::c_int; 3usize],
        pub maxTexture2DGather: [::core::ffi::c_int; 2usize],
        pub maxTexture3D: [::core::ffi::c_int; 3usize],
        pub maxTexture3DAlt: [::core::ffi::c_int; 3usize],
        pub maxTextureCubemap: ::core::ffi::c_int,
        pub maxTexture1DLayered: [::core::ffi::c_int; 2usize],
        pub maxTexture2DLayered: [::core::ffi::c_int; 3usize],
        pub maxTextureCubemapLayered: [::core::ffi::c_int; 2usize],
        pub maxSurface1D: ::core::ffi::c_int,
        pub maxSurface2D: [::core::ffi::c_int; 2usize],
        pub maxSurface3D: [::core::ffi::c_int; 3usize],
        pub maxSurface1DLayered: [::core::ffi::c_int; 2usize],
        pub maxSurface2DLayered: [::core::ffi::c_int; 3usize],
        pub maxSurfaceCubemap: ::core::ffi::c_int,
        pub maxSurfaceCubemapLayered: [::core::ffi::c_int; 2usize],
        pub surfaceAlignment: usize,
        pub concurrentKernels: ::core::ffi::c_int,
        pub ECCEnabled: ::core::ffi::c_int,
        pub pciBusID: ::core::ffi::c_int,
        pub pciDeviceID: ::core::ffi::c_int,
        pub pciDomainID: ::core::ffi::c_int,
        pub tccDriver: ::core::ffi::c_int,
        pub asyncEngineCount: ::core::ffi::c_int,
        pub unifiedAddressing: ::core::ffi::c_int,
        pub memoryClockRate: ::core::ffi::c_int,
        pub memoryBusWidth: ::core::ffi::c_int,
        pub l2CacheSize: ::core::ffi::c_int,
        pub persistingL2CacheMaxSize: ::core::ffi::c_int,
        pub maxThreadsPerMultiProcessor: ::core::ffi::c_int,
        pub streamPrioritiesSupported: ::core::ffi::c_int,
        pub globalL1CacheSupported: ::core::ffi::c_int,
        pub localL1CacheSupported: ::core::ffi::c_int,
        pub sharedMemPerMultiprocessor: usize,
        pub regsPerMultiprocessor: ::core::ffi::c_int,
        pub managedMemory: ::core::ffi::c_int,
        pub isMultiGpuBoard: ::core::ffi::c_int,
        pub multiGpuBoardGroupID: ::core::ffi::c_int,
        pub hostNativeAtomicSupported: ::core::ffi::c_int,
        pub singleToDoublePrecisionPerfRatio: ::core::ffi::c_int,
        pub pageableMemoryAccess: ::core::ffi::c_int,
        pub concurrentManagedAccess: ::core::ffi::c_int,
        pub computePreemptionSupported: ::core::ffi::c_int,
        pub canUseHostPointerForRegisteredMem: ::core::ffi::c_int,
        pub cooperativeLaunch: ::core::ffi::c_int,
        pub cooperativeMultiDeviceLaunch: ::core::ffi::c_int,
        pub sharedMemPerBlockOptin: usize,
        pub pageableMemoryAccessUsesHostPageTables: ::core::ffi::c_int,
        pub directManagedMemAccessFromHost: ::core::ffi::c_int,
        pub maxBlocksPerMultiProcessor: ::core::ffi::c_int,
        pub accessPolicyMaxWindowSize: ::core::ffi::c_int,
        pub reservedSharedMemPerBlock: usize,
        pub hostRegisterSupported: ::core::ffi::c_int,
        pub sparseCudaArraySupported: ::core::ffi::c_int,
        pub hostRegisterReadOnlySupported: ::core::ffi::c_int,
        pub timelineSemaphoreInteropSupported: ::core::ffi::c_int,
        pub memoryPoolsSupported: ::core::ffi::c_int,
        pub gpuDirectRDMASupported: ::core::ffi::c_int,
        pub gpuDirectRDMAFlushWritesOptions: ::core::ffi::c_uint,
        pub gpuDirectRDMAWritesOrdering: ::core::ffi::c_int,
        pub memoryPoolSupportedHandleTypes: ::core::ffi::c_uint,
        pub deferredMappingCudaArraySupported: ::core::ffi::c_int,
        pub ipcEventSupported: ::core::ffi::c_int,
        pub clusterLaunch: ::core::ffi::c_int,
        pub unifiedFunctionPointers: ::core::ffi::c_int,
        pub reserved2: [::core::ffi::c_int; 2usize],
        pub reserved1: [::core::ffi::c_int; 1usize],
        pub reserved: [::core::ffi::c_int; 60usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaIpcEventHandle_st {
        pub reserved: [::core::ffi::c_char; 64usize],
    }
    pub type cudaIpcEventHandle_t = root::cudaIpcEventHandle_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaIpcMemHandle_st {
        pub reserved: [::core::ffi::c_char; 64usize],
    }
    pub type cudaIpcMemHandle_t = root::cudaIpcMemHandle_st;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueFd:
        root::cudaExternalMemoryHandleType = 1;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32:
        root::cudaExternalMemoryHandleType = 2;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeOpaqueWin32Kmt:
        root::cudaExternalMemoryHandleType = 3;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Heap:
        root::cudaExternalMemoryHandleType = 4;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D12Resource:
        root::cudaExternalMemoryHandleType = 5;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11Resource:
        root::cudaExternalMemoryHandleType = 6;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeD3D11ResourceKmt:
        root::cudaExternalMemoryHandleType = 7;
    pub const cudaExternalMemoryHandleType_cudaExternalMemoryHandleTypeNvSciBuf:
        root::cudaExternalMemoryHandleType = 8;
    pub type cudaExternalMemoryHandleType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalMemoryHandleDesc {
        pub type_: root::cudaExternalMemoryHandleType,
        pub handle: root::cudaExternalMemoryHandleDesc__bindgen_ty_1,
        pub size: ::core::ffi::c_ulonglong,
        pub flags: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaExternalMemoryHandleDesc__bindgen_ty_1 {
        pub fd: ::core::ffi::c_int,
        pub win32: root::cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1,
        pub nvSciBufObject: *const ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalMemoryHandleDesc__bindgen_ty_1__bindgen_ty_1 {
        pub handle: *mut ::core::ffi::c_void,
        pub name: *const ::core::ffi::c_void,
    }
    impl ::core::fmt::Debug for cudaExternalMemoryHandleDesc__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "cudaExternalMemoryHandleDesc__bindgen_ty_1 {{ union }}")
        }
    }
    impl ::core::fmt::Debug for cudaExternalMemoryHandleDesc {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write ! (f , "cudaExternalMemoryHandleDesc {{ type: {:?}, handle: {:?}, size: {:?}, flags: {:?} }}" , self . type_ , self . handle , self . size , self . flags)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalMemoryBufferDesc {
        pub offset: ::core::ffi::c_ulonglong,
        pub size: ::core::ffi::c_ulonglong,
        pub flags: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalMemoryMipmappedArrayDesc {
        pub offset: ::core::ffi::c_ulonglong,
        pub formatDesc: root::cudaChannelFormatDesc,
        pub extent: root::cudaExtent,
        pub flags: ::core::ffi::c_uint,
        pub numLevels: ::core::ffi::c_uint,
    }
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueFd:
        root::cudaExternalSemaphoreHandleType = 1;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32:
        root::cudaExternalSemaphoreHandleType = 2;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt:
        root::cudaExternalSemaphoreHandleType = 3;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D12Fence:
        root::cudaExternalSemaphoreHandleType = 4;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeD3D11Fence:
        root::cudaExternalSemaphoreHandleType = 5;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeNvSciSync:
        root::cudaExternalSemaphoreHandleType = 6;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutex:
        root::cudaExternalSemaphoreHandleType = 7;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeKeyedMutexKmt:
        root::cudaExternalSemaphoreHandleType = 8;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd:
        root::cudaExternalSemaphoreHandleType = 9;
    pub const cudaExternalSemaphoreHandleType_cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 : root :: cudaExternalSemaphoreHandleType = 10 ;
    pub type cudaExternalSemaphoreHandleType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalSemaphoreHandleDesc {
        pub type_: root::cudaExternalSemaphoreHandleType,
        pub handle: root::cudaExternalSemaphoreHandleDesc__bindgen_ty_1,
        pub flags: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
        pub fd: ::core::ffi::c_int,
        pub win32: root::cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1,
        pub nvSciSyncObj: *const ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreHandleDesc__bindgen_ty_1__bindgen_ty_1 {
        pub handle: *mut ::core::ffi::c_void,
        pub name: *const ::core::ffi::c_void,
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreHandleDesc__bindgen_ty_1 {{ union }}"
            )
        }
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreHandleDesc {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreHandleDesc {{ type: {:?}, handle: {:?}, flags: {:?} }}",
                self.type_, self.handle, self.flags
            )
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalParams {
        pub params: root::cudaExternalSemaphoreSignalParams__bindgen_ty_1,
        pub flags: ::core::ffi::c_uint,
        pub reserved: [::core::ffi::c_uint; 16usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
        pub fence: root::cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1,
        pub nvSciSync: root::cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2,
        pub keyedMutex: root::cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3,
        pub reserved: [::core::ffi::c_uint; 12usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_1 {
        pub value: ::core::ffi::c_ulonglong,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
        pub fence: *mut ::core::ffi::c_void,
        pub reserved: ::core::ffi::c_ulonglong,
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_2 {{ union }}"
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalParams__bindgen_ty_1__bindgen_ty_3 {
        pub key: ::core::ffi::c_ulonglong,
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreSignalParams__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write ! (f , "cudaExternalSemaphoreSignalParams__bindgen_ty_1 {{ fence: {:?}, nvSciSync: {:?}, keyedMutex: {:?}, reserved: {:?} }}" , self . fence , self . nvSciSync , self . keyedMutex , self . reserved)
        }
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreSignalParams {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreSignalParams {{ params: {:?}, flags: {:?}, reserved: {:?} }}",
                self.params, self.flags, self.reserved
            )
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitParams {
        pub params: root::cudaExternalSemaphoreWaitParams__bindgen_ty_1,
        pub flags: ::core::ffi::c_uint,
        pub reserved: [::core::ffi::c_uint; 16usize],
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
        pub fence: root::cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1,
        pub nvSciSync: root::cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2,
        pub keyedMutex: root::cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3,
        pub reserved: [::core::ffi::c_uint; 10usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_1 {
        pub value: ::core::ffi::c_ulonglong,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
        pub fence: *mut ::core::ffi::c_void,
        pub reserved: ::core::ffi::c_ulonglong,
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_2 {{ union }}"
            )
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitParams__bindgen_ty_1__bindgen_ty_3 {
        pub key: ::core::ffi::c_ulonglong,
        pub timeoutMs: ::core::ffi::c_uint,
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreWaitParams__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write ! (f , "cudaExternalSemaphoreWaitParams__bindgen_ty_1 {{ fence: {:?}, nvSciSync: {:?}, keyedMutex: {:?}, reserved: {:?} }}" , self . fence , self . nvSciSync , self . keyedMutex , self . reserved)
        }
    }
    impl ::core::fmt::Debug for cudaExternalSemaphoreWaitParams {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaExternalSemaphoreWaitParams {{ params: {:?}, flags: {:?}, reserved: {:?} }}",
                self.params, self.flags, self.reserved
            )
        }
    }
    pub use self::super::root::cudaError as cudaError_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUstream_st {
        _unused: [u8; 0],
    }
    pub type cudaStream_t = *mut root::CUstream_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUevent_st {
        _unused: [u8; 0],
    }
    pub type cudaEvent_t = *mut root::CUevent_st;
    pub type cudaGraphicsResource_t = *mut root::cudaGraphicsResource;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUexternalMemory_st {
        _unused: [u8; 0],
    }
    pub type cudaExternalMemory_t = *mut root::CUexternalMemory_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUexternalSemaphore_st {
        _unused: [u8; 0],
    }
    pub type cudaExternalSemaphore_t = *mut root::CUexternalSemaphore_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUgraph_st {
        _unused: [u8; 0],
    }
    pub type cudaGraph_t = *mut root::CUgraph_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUgraphNode_st {
        _unused: [u8; 0],
    }
    pub type cudaGraphNode_t = *mut root::CUgraphNode_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUuserObject_st {
        _unused: [u8; 0],
    }
    pub type cudaUserObject_t = *mut root::CUuserObject_st;
    pub type cudaGraphConditionalHandle = ::core::ffi::c_ulonglong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUfunc_st {
        _unused: [u8; 0],
    }
    pub type cudaFunction_t = *mut root::CUfunc_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUkern_st {
        _unused: [u8; 0],
    }
    pub type cudaKernel_t = *mut root::CUkern_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUmemPoolHandle_st {
        _unused: [u8; 0],
    }
    pub type cudaMemPool_t = *mut root::CUmemPoolHandle_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchParams {
        pub func: *mut ::core::ffi::c_void,
        pub gridDim: root::dim3,
        pub blockDim: root::dim3,
        pub args: *mut *mut ::core::ffi::c_void,
        pub sharedMem: usize,
        pub stream: root::cudaStream_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaKernelNodeParams {
        pub func: *mut ::core::ffi::c_void,
        pub gridDim: root::dim3,
        pub blockDim: root::dim3,
        pub sharedMemBytes: ::core::ffi::c_uint,
        pub kernelParams: *mut *mut ::core::ffi::c_void,
        pub extra: *mut *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaKernelNodeParamsV2 {
        pub func: *mut ::core::ffi::c_void,
        pub gridDim: root::dim3,
        pub blockDim: root::dim3,
        pub sharedMemBytes: ::core::ffi::c_uint,
        pub kernelParams: *mut *mut ::core::ffi::c_void,
        pub extra: *mut *mut ::core::ffi::c_void,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalNodeParams {
        pub extSemArray: *mut root::cudaExternalSemaphore_t,
        pub paramsArray: *const root::cudaExternalSemaphoreSignalParams,
        pub numExtSems: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreSignalNodeParamsV2 {
        pub extSemArray: *mut root::cudaExternalSemaphore_t,
        pub paramsArray: *const root::cudaExternalSemaphoreSignalParams,
        pub numExtSems: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitNodeParams {
        pub extSemArray: *mut root::cudaExternalSemaphore_t,
        pub paramsArray: *const root::cudaExternalSemaphoreWaitParams,
        pub numExtSems: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaExternalSemaphoreWaitNodeParamsV2 {
        pub extSemArray: *mut root::cudaExternalSemaphore_t,
        pub paramsArray: *const root::cudaExternalSemaphoreWaitParams,
        pub numExtSems: ::core::ffi::c_uint,
    }
    pub const cudaGraphConditionalNodeType_cudaGraphCondTypeIf: root::cudaGraphConditionalNodeType =
        0;
    pub const cudaGraphConditionalNodeType_cudaGraphCondTypeWhile:
        root::cudaGraphConditionalNodeType = 1;
    pub type cudaGraphConditionalNodeType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaConditionalNodeParams {
        pub handle: root::cudaGraphConditionalHandle,
        pub type_: root::cudaGraphConditionalNodeType,
        pub size: ::core::ffi::c_uint,
        pub phGraph_out: *mut root::cudaGraph_t,
    }
    pub const cudaGraphNodeType_cudaGraphNodeTypeKernel: root::cudaGraphNodeType = 0;
    pub const cudaGraphNodeType_cudaGraphNodeTypeMemcpy: root::cudaGraphNodeType = 1;
    pub const cudaGraphNodeType_cudaGraphNodeTypeMemset: root::cudaGraphNodeType = 2;
    pub const cudaGraphNodeType_cudaGraphNodeTypeHost: root::cudaGraphNodeType = 3;
    pub const cudaGraphNodeType_cudaGraphNodeTypeGraph: root::cudaGraphNodeType = 4;
    pub const cudaGraphNodeType_cudaGraphNodeTypeEmpty: root::cudaGraphNodeType = 5;
    pub const cudaGraphNodeType_cudaGraphNodeTypeWaitEvent: root::cudaGraphNodeType = 6;
    pub const cudaGraphNodeType_cudaGraphNodeTypeEventRecord: root::cudaGraphNodeType = 7;
    pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreSignal: root::cudaGraphNodeType = 8;
    pub const cudaGraphNodeType_cudaGraphNodeTypeExtSemaphoreWait: root::cudaGraphNodeType = 9;
    pub const cudaGraphNodeType_cudaGraphNodeTypeMemAlloc: root::cudaGraphNodeType = 10;
    pub const cudaGraphNodeType_cudaGraphNodeTypeMemFree: root::cudaGraphNodeType = 11;
    pub const cudaGraphNodeType_cudaGraphNodeTypeConditional: root::cudaGraphNodeType = 13;
    pub const cudaGraphNodeType_cudaGraphNodeTypeCount: root::cudaGraphNodeType = 14;
    pub type cudaGraphNodeType = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaChildGraphNodeParams {
        pub graph: root::cudaGraph_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaEventRecordNodeParams {
        pub event: root::cudaEvent_t,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaEventWaitNodeParams {
        pub event: root::cudaEvent_t,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaGraphNodeParams {
        pub type_: root::cudaGraphNodeType,
        pub reserved0: [::core::ffi::c_int; 3usize],
        pub __bindgen_anon_1: root::cudaGraphNodeParams__bindgen_ty_1,
        pub reserved2: ::core::ffi::c_longlong,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaGraphNodeParams__bindgen_ty_1 {
        pub reserved1: [::core::ffi::c_longlong; 29usize],
        pub kernel: root::cudaKernelNodeParamsV2,
        pub memcpy: root::cudaMemcpyNodeParams,
        pub memset: root::cudaMemsetParamsV2,
        pub host: root::cudaHostNodeParamsV2,
        pub graph: root::cudaChildGraphNodeParams,
        pub eventWait: root::cudaEventWaitNodeParams,
        pub eventRecord: root::cudaEventRecordNodeParams,
        pub extSemSignal: root::cudaExternalSemaphoreSignalNodeParamsV2,
        pub extSemWait: root::cudaExternalSemaphoreWaitNodeParamsV2,
        pub alloc: root::cudaMemAllocNodeParamsV2,
        pub free: root::cudaMemFreeNodeParams,
        pub conditional: root::cudaConditionalNodeParams,
    }
    impl ::core::fmt::Debug for cudaGraphNodeParams__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "cudaGraphNodeParams__bindgen_ty_1 {{ union }}")
        }
    }
    impl ::core::fmt::Debug for cudaGraphNodeParams {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write ! (f , "cudaGraphNodeParams {{ type: {:?}, reserved0: {:?}, __bindgen_anon_1: {:?}, reserved2: {:?} }}" , self . type_ , self . reserved0 , self . __bindgen_anon_1 , self . reserved2)
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaGraphEdgeData_st {
        pub from_port: ::core::ffi::c_uchar,
        pub to_port: ::core::ffi::c_uchar,
        pub type_: ::core::ffi::c_uchar,
        pub reserved: [::core::ffi::c_uchar; 5usize],
    }
    pub type cudaGraphEdgeData = root::cudaGraphEdgeData_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUgraphExec_st {
        _unused: [u8; 0],
    }
    pub type cudaGraphExec_t = *mut root::CUgraphExec_st;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateSuccess:
        root::cudaGraphExecUpdateResult = 0;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateError: root::cudaGraphExecUpdateResult =
        1;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorTopologyChanged:
        root::cudaGraphExecUpdateResult = 2;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNodeTypeChanged:
        root::cudaGraphExecUpdateResult = 3;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorFunctionChanged:
        root::cudaGraphExecUpdateResult = 4;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorParametersChanged:
        root::cudaGraphExecUpdateResult = 5;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorNotSupported:
        root::cudaGraphExecUpdateResult = 6;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorUnsupportedFunctionChange:
        root::cudaGraphExecUpdateResult = 7;
    pub const cudaGraphExecUpdateResult_cudaGraphExecUpdateErrorAttributesChanged:
        root::cudaGraphExecUpdateResult = 8;
    pub type cudaGraphExecUpdateResult = ::core::ffi::c_int;
    pub const cudaGraphInstantiateResult_cudaGraphInstantiateSuccess:
        root::cudaGraphInstantiateResult = 0;
    pub const cudaGraphInstantiateResult_cudaGraphInstantiateError:
        root::cudaGraphInstantiateResult = 1;
    pub const cudaGraphInstantiateResult_cudaGraphInstantiateInvalidStructure:
        root::cudaGraphInstantiateResult = 2;
    pub const cudaGraphInstantiateResult_cudaGraphInstantiateNodeOperationNotSupported:
        root::cudaGraphInstantiateResult = 3;
    pub const cudaGraphInstantiateResult_cudaGraphInstantiateMultipleDevicesNotSupported:
        root::cudaGraphInstantiateResult = 4;
    pub type cudaGraphInstantiateResult = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaGraphInstantiateParams_st {
        pub flags: ::core::ffi::c_ulonglong,
        pub uploadStream: root::cudaStream_t,
        pub errNode_out: root::cudaGraphNode_t,
        pub result_out: root::cudaGraphInstantiateResult,
    }
    pub type cudaGraphInstantiateParams = root::cudaGraphInstantiateParams_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaGraphExecUpdateResultInfo_st {
        pub result: root::cudaGraphExecUpdateResult,
        pub errorNode: root::cudaGraphNode_t,
        pub errorFromNode: root::cudaGraphNode_t,
    }
    pub type cudaGraphExecUpdateResultInfo = root::cudaGraphExecUpdateResultInfo_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CUgraphDeviceUpdatableNode_st {
        _unused: [u8; 0],
    }
    pub type cudaGraphDeviceNode_t = *mut root::CUgraphDeviceUpdatableNode_st;
    pub const cudaDriverEntryPointQueryResult_cudaDriverEntryPointSuccess:
        root::cudaDriverEntryPointQueryResult = 0;
    pub const cudaDriverEntryPointQueryResult_cudaDriverEntryPointSymbolNotFound:
        root::cudaDriverEntryPointQueryResult = 1;
    pub const cudaDriverEntryPointQueryResult_cudaDriverEntryPointVersionNotSufficent:
        root::cudaDriverEntryPointQueryResult = 2;
    pub type cudaDriverEntryPointQueryResult = ::core::ffi::c_int;
    pub const cudaLaunchMemSyncDomain_cudaLaunchMemSyncDomainDefault:
        root::cudaLaunchMemSyncDomain = 0;
    pub const cudaLaunchMemSyncDomain_cudaLaunchMemSyncDomainRemote: root::cudaLaunchMemSyncDomain =
        1;
    pub type cudaLaunchMemSyncDomain = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchMemSyncDomainMap_st {
        pub default_: ::core::ffi::c_uchar,
        pub remote: ::core::ffi::c_uchar,
    }
    pub type cudaLaunchMemSyncDomainMap = root::cudaLaunchMemSyncDomainMap_st;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeIgnore: root::cudaLaunchAttributeID = 0;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeAccessPolicyWindow:
        root::cudaLaunchAttributeID = 1;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeCooperative: root::cudaLaunchAttributeID = 2;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeSynchronizationPolicy:
        root::cudaLaunchAttributeID = 3;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeClusterDimension:
        root::cudaLaunchAttributeID = 4;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeClusterSchedulingPolicyPreference:
        root::cudaLaunchAttributeID = 5;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeProgrammaticStreamSerialization:
        root::cudaLaunchAttributeID = 6;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeProgrammaticEvent:
        root::cudaLaunchAttributeID = 7;
    pub const cudaLaunchAttributeID_cudaLaunchAttributePriority: root::cudaLaunchAttributeID = 8;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeMemSyncDomainMap:
        root::cudaLaunchAttributeID = 9;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeMemSyncDomain: root::cudaLaunchAttributeID =
        10;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeLaunchCompletionEvent:
        root::cudaLaunchAttributeID = 12;
    pub const cudaLaunchAttributeID_cudaLaunchAttributeDeviceUpdatableKernelNode:
        root::cudaLaunchAttributeID = 13;
    pub const cudaLaunchAttributeID_cudaLaunchAttributePreferredSharedMemoryCarveout:
        root::cudaLaunchAttributeID = 14;
    pub type cudaLaunchAttributeID = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaLaunchAttributeValue {
        pub pad: [::core::ffi::c_char; 64usize],
        pub accessPolicyWindow: root::cudaAccessPolicyWindow,
        pub cooperative: ::core::ffi::c_int,
        pub syncPolicy: root::cudaSynchronizationPolicy,
        pub clusterDim: root::cudaLaunchAttributeValue__bindgen_ty_1,
        pub clusterSchedulingPolicyPreference: root::cudaClusterSchedulingPolicy,
        pub programmaticStreamSerializationAllowed: ::core::ffi::c_int,
        pub programmaticEvent: root::cudaLaunchAttributeValue__bindgen_ty_2,
        pub priority: ::core::ffi::c_int,
        pub memSyncDomainMap: root::cudaLaunchMemSyncDomainMap,
        pub memSyncDomain: root::cudaLaunchMemSyncDomain,
        pub launchCompletionEvent: root::cudaLaunchAttributeValue__bindgen_ty_3,
        pub deviceUpdatableKernelNode: root::cudaLaunchAttributeValue__bindgen_ty_4,
        pub sharedMemCarveout: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchAttributeValue__bindgen_ty_1 {
        pub x: ::core::ffi::c_uint,
        pub y: ::core::ffi::c_uint,
        pub z: ::core::ffi::c_uint,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchAttributeValue__bindgen_ty_2 {
        pub event: root::cudaEvent_t,
        pub flags: ::core::ffi::c_int,
        pub triggerAtBlockStart: ::core::ffi::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchAttributeValue__bindgen_ty_3 {
        pub event: root::cudaEvent_t,
        pub flags: ::core::ffi::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchAttributeValue__bindgen_ty_4 {
        pub deviceUpdatable: ::core::ffi::c_int,
        pub devNode: root::cudaGraphDeviceNode_t,
    }
    impl ::core::fmt::Debug for cudaLaunchAttributeValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "cudaLaunchAttributeValue {{ union }}")
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaLaunchAttribute_st {
        pub id: root::cudaLaunchAttributeID,
        pub pad: [::core::ffi::c_char; 4usize],
        pub val: root::cudaLaunchAttributeValue,
    }
    impl ::core::fmt::Debug for cudaLaunchAttribute_st {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaLaunchAttribute_st {{ id: {:?}, pad: {:?}, val: {:?} }}",
                self.id, self.pad, self.val
            )
        }
    }
    pub type cudaLaunchAttribute = root::cudaLaunchAttribute_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaLaunchConfig_st {
        pub gridDim: root::dim3,
        pub blockDim: root::dim3,
        pub dynamicSmemBytes: usize,
        pub stream: root::cudaStream_t,
        pub attrs: *mut root::cudaLaunchAttribute,
        pub numAttrs: ::core::ffi::c_uint,
    }
    pub type cudaLaunchConfig_t = root::cudaLaunchConfig_st;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaAsyncCallbackEntry {
        _unused: [u8; 0],
    }
    pub type cudaAsyncCallbackHandle_t = *mut root::cudaAsyncCallbackEntry;
    pub const cudaAsyncNotificationType_enum_cudaAsyncNotificationTypeOverBudget:
        root::cudaAsyncNotificationType_enum = 1;
    pub type cudaAsyncNotificationType_enum = ::core::ffi::c_int;
    pub use self::super::root::cudaAsyncNotificationType_enum as cudaAsyncNotificationType;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct cudaAsyncNotificationInfo {
        pub type_: root::cudaAsyncNotificationType,
        pub info: root::cudaAsyncNotificationInfo__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union cudaAsyncNotificationInfo__bindgen_ty_1 {
        pub overBudget: root::cudaAsyncNotificationInfo__bindgen_ty_1__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaAsyncNotificationInfo__bindgen_ty_1__bindgen_ty_1 {
        pub bytesOverBudget: ::core::ffi::c_ulonglong,
    }
    impl ::core::fmt::Debug for cudaAsyncNotificationInfo__bindgen_ty_1 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(f, "cudaAsyncNotificationInfo__bindgen_ty_1 {{ union }}")
        }
    }
    impl ::core::fmt::Debug for cudaAsyncNotificationInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            write!(
                f,
                "cudaAsyncNotificationInfo {{ type: {:?}, info: {:?} }}",
                self.type_, self.info
            )
        }
    }
    pub type cudaAsyncNotificationInfo_t = root::cudaAsyncNotificationInfo;
    pub type cudaAsyncCallback = ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::cudaAsyncNotificationInfo_t,
            arg2: *mut ::core::ffi::c_void,
            arg3: root::cudaAsyncCallbackHandle_t,
        ),
    >;
    pub type cudaSurfaceObject_t = ::core::ffi::c_ulonglong;
    pub const cudaTextureAddressMode_cudaAddressModeWrap: root::cudaTextureAddressMode = 0;
    pub const cudaTextureAddressMode_cudaAddressModeClamp: root::cudaTextureAddressMode = 1;
    pub const cudaTextureAddressMode_cudaAddressModeMirror: root::cudaTextureAddressMode = 2;
    pub const cudaTextureAddressMode_cudaAddressModeBorder: root::cudaTextureAddressMode = 3;
    pub type cudaTextureAddressMode = ::core::ffi::c_int;
    pub const cudaTextureFilterMode_cudaFilterModePoint: root::cudaTextureFilterMode = 0;
    pub const cudaTextureFilterMode_cudaFilterModeLinear: root::cudaTextureFilterMode = 1;
    pub type cudaTextureFilterMode = ::core::ffi::c_int;
    pub const cudaTextureReadMode_cudaReadModeElementType: root::cudaTextureReadMode = 0;
    pub const cudaTextureReadMode_cudaReadModeNormalizedFloat: root::cudaTextureReadMode = 1;
    pub type cudaTextureReadMode = ::core::ffi::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudaTextureDesc {
        pub addressMode: [root::cudaTextureAddressMode; 3usize],
        pub filterMode: root::cudaTextureFilterMode,
        pub readMode: root::cudaTextureReadMode,
        pub sRGB: ::core::ffi::c_int,
        pub borderColor: [f32; 4usize],
        pub normalizedCoords: ::core::ffi::c_int,
        pub maxAnisotropy: ::core::ffi::c_uint,
        pub mipmapFilterMode: root::cudaTextureFilterMode,
        pub mipmapLevelBias: f32,
        pub minMipmapLevelClamp: f32,
        pub maxMipmapLevelClamp: f32,
        pub disableTrilinearOptimization: ::core::ffi::c_int,
        pub seamlessCubemap: ::core::ffi::c_int,
    }
    pub type cudaTextureObject_t = ::core::ffi::c_ulonglong;
    pub type cudaStreamCallback_t = ::core::option::Option<
        unsafe extern "C" fn(
            stream: root::cudaStream_t,
            status: root::cudaError_t,
            userData: *mut ::core::ffi::c_void,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cublasContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct cudnnContext {
        _unused: [u8; 0],
    }
    pub mod nvinfer1 {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type char_t = ::core::ffi::c_char;
        pub type AsciiChar = root::nvinfer1::char_t;
        pub mod v_1_0 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct IErrorRecorder {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            pub type IErrorRecorder_ErrorDesc = *const ::core::ffi::c_char;
            pub type IErrorRecorder_RefCount = i32;
            pub const IErrorRecorder_kMAX_DESC_LENGTH: usize = 127;
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginCapability {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginResource {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginCreatorInterface {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginV3 {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginCreator {
                pub _base: root::nvinfer1::v_1_0::IPluginCreatorInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IStreamReader {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IStreamReaderV2 {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginV3OneCore {
                pub _base: root::nvinfer1::v_1_0::IPluginCapability,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginV3OneBuild {
                pub _base: root::nvinfer1::v_1_0::IPluginCapability,
            }
            pub const IPluginV3OneBuild_kDEFAULT_FORMAT_COMBINATION_LIMIT: i32 = 100;
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginV3OneRuntime {
                pub _base: root::nvinfer1::v_1_0::IPluginCapability,
            }
            #[repr(C)]
            pub struct IProfiler__bindgen_vtable(::core::ffi::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProfiler {
                pub vtable_: *const IProfiler__bindgen_vtable,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IGpuAllocator {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IOutputAllocator {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IDebugListener {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IGpuAsyncAllocator {
                pub _base: root::nvinfer1::v_1_0::IGpuAllocator,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginCreatorV3One {
                pub _base: root::nvinfer1::v_1_0::IPluginCreatorInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IInt8EntropyCalibrator {
                pub _base: root::nvinfer1::IInt8Calibrator,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IInt8EntropyCalibrator2 {
                pub _base: root::nvinfer1::IInt8Calibrator,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IInt8MinMaxCalibrator {
                pub _base: root::nvinfer1::IInt8Calibrator,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IInt8LegacyCalibrator {
                pub _base: root::nvinfer1::IInt8Calibrator,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAlgorithmSelector {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct IProgressMonitor {
                pub _base: root::nvinfer1::IVersionedInterface,
            }
        }
        pub type IErrorRecorder = root::nvinfer1::v_1_0::IErrorRecorder;
        pub mod impl_ {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DataType {
            kFLOAT = 0,
            kHALF = 1,
            kINT8 = 2,
            kINT32 = 3,
            kBOOL = 4,
            kUINT8 = 5,
            kFP8 = 6,
            kBF16 = 7,
            kINT64 = 8,
            kINT4 = 9,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Dims64 {
            pub nbDims: i32,
            pub d: [i64; 8usize],
        }
        pub const Dims64_MAX_DIMS: i32 = 8;
        pub type Dims = root::nvinfer1::Dims64;
        pub type InterfaceKind = *const ::core::ffi::c_char;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct InterfaceInfo {
            pub kind: root::nvinfer1::InterfaceKind,
            pub major: i32,
            pub minor: i32,
        }
        pub const APILanguage_kCPP: root::nvinfer1::APILanguage = 0;
        pub const APILanguage_kPYTHON: root::nvinfer1::APILanguage = 1;
        pub type APILanguage = i32;
        #[repr(C)]
        pub struct IVersionedInterface__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IVersionedInterface {
            pub vtable_: *const IVersionedInterface__bindgen_vtable,
        }
        pub const ErrorCode_kSUCCESS: root::nvinfer1::ErrorCode = 0;
        pub const ErrorCode_kUNSPECIFIED_ERROR: root::nvinfer1::ErrorCode = 1;
        pub const ErrorCode_kINTERNAL_ERROR: root::nvinfer1::ErrorCode = 2;
        pub const ErrorCode_kINVALID_ARGUMENT: root::nvinfer1::ErrorCode = 3;
        pub const ErrorCode_kINVALID_CONFIG: root::nvinfer1::ErrorCode = 4;
        pub const ErrorCode_kFAILED_ALLOCATION: root::nvinfer1::ErrorCode = 5;
        pub const ErrorCode_kFAILED_INITIALIZATION: root::nvinfer1::ErrorCode = 6;
        pub const ErrorCode_kFAILED_EXECUTION: root::nvinfer1::ErrorCode = 7;
        pub const ErrorCode_kFAILED_COMPUTATION: root::nvinfer1::ErrorCode = 8;
        pub const ErrorCode_kINVALID_STATE: root::nvinfer1::ErrorCode = 9;
        pub const ErrorCode_kUNSUPPORTED_STATE: root::nvinfer1::ErrorCode = 10;
        pub type ErrorCode = i32;
        pub const TensorIOMode_kNONE: root::nvinfer1::TensorIOMode = 0;
        pub const TensorIOMode_kINPUT: root::nvinfer1::TensorIOMode = 1;
        pub const TensorIOMode_kOUTPUT: root::nvinfer1::TensorIOMode = 2;
        pub type TensorIOMode = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Dims2 {
            pub _base: root::nvinfer1::Dims,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DimsHW {
            pub _base: root::nvinfer1::Dims2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Dims3 {
            pub _base: root::nvinfer1::Dims2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Dims4 {
            pub _base: root::nvinfer1::Dims3,
        }
        pub const PluginFieldType_kFLOAT16: root::nvinfer1::PluginFieldType = 0;
        pub const PluginFieldType_kFLOAT32: root::nvinfer1::PluginFieldType = 1;
        pub const PluginFieldType_kFLOAT64: root::nvinfer1::PluginFieldType = 2;
        pub const PluginFieldType_kINT8: root::nvinfer1::PluginFieldType = 3;
        pub const PluginFieldType_kINT16: root::nvinfer1::PluginFieldType = 4;
        pub const PluginFieldType_kINT32: root::nvinfer1::PluginFieldType = 5;
        pub const PluginFieldType_kCHAR: root::nvinfer1::PluginFieldType = 6;
        pub const PluginFieldType_kDIMS: root::nvinfer1::PluginFieldType = 7;
        pub const PluginFieldType_kUNKNOWN: root::nvinfer1::PluginFieldType = 8;
        pub const PluginFieldType_kBF16: root::nvinfer1::PluginFieldType = 9;
        pub const PluginFieldType_kINT64: root::nvinfer1::PluginFieldType = 10;
        pub const PluginFieldType_kFP8: root::nvinfer1::PluginFieldType = 11;
        pub const PluginFieldType_kINT4: root::nvinfer1::PluginFieldType = 12;
        pub type PluginFieldType = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PluginField {
            pub name: *const root::nvinfer1::AsciiChar,
            pub data: *const ::core::ffi::c_void,
            pub type_: root::nvinfer1::PluginFieldType,
            pub length: i32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PluginFieldCollection {
            pub nbFields: i32,
            pub fields: *const root::nvinfer1::PluginField,
        }
        pub const TensorRTPhase_kBUILD: root::nvinfer1::TensorRTPhase = 0;
        pub const TensorRTPhase_kRUNTIME: root::nvinfer1::TensorRTPhase = 1;
        pub type TensorRTPhase = i32;
        pub const PluginCapabilityType_kCORE: root::nvinfer1::PluginCapabilityType = 0;
        pub const PluginCapabilityType_kBUILD: root::nvinfer1::PluginCapabilityType = 1;
        pub const PluginCapabilityType_kRUNTIME: root::nvinfer1::PluginCapabilityType = 2;
        pub type PluginCapabilityType = i32;
        pub type IPluginResource = root::nvinfer1::v_1_0::IPluginResource;
        pub type IPluginCreatorInterface = root::nvinfer1::v_1_0::IPluginCreatorInterface;
        pub type IPluginV3 = root::nvinfer1::v_1_0::IPluginV3;
        pub type IPluginCapability = root::nvinfer1::v_1_0::IPluginCapability;
        pub type IGpuAllocator = root::nvinfer1::v_1_0::IGpuAllocator;
        pub use self::super::super::root::nvinfer1::TensorFormat as PluginFormat;
        pub const kPLUGIN_VERSION_PYTHON_BIT: i32 = 64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PluginTensorDesc {
            pub dims: root::nvinfer1::Dims,
            pub type_: root::nvinfer1::DataType,
            pub format: root::nvinfer1::TensorFormat,
            pub scale: f32,
        }
        pub const PluginVersion_kV2: root::nvinfer1::PluginVersion = 0;
        pub const PluginVersion_kV2_EXT: root::nvinfer1::PluginVersion = 1;
        pub const PluginVersion_kV2_IOEXT: root::nvinfer1::PluginVersion = 2;
        pub const PluginVersion_kV2_DYNAMICEXT: root::nvinfer1::PluginVersion = 3;
        pub const PluginVersion_kV2_DYNAMICEXT_PYTHON: root::nvinfer1::PluginVersion = 67;
        pub type PluginVersion = u8;
        pub const PluginCreatorVersion_kV1: root::nvinfer1::PluginCreatorVersion = 0;
        pub const PluginCreatorVersion_kV1_PYTHON: root::nvinfer1::PluginCreatorVersion = 64;
        pub type PluginCreatorVersion = i32;
        #[repr(C)]
        pub struct IPluginV2__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV2 {
            pub vtable_: *const IPluginV2__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV2Ext {
            pub _base: root::nvinfer1::IPluginV2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV2IOExt {
            pub _base: root::nvinfer1::IPluginV2Ext,
        }
        pub type IPluginCreator = root::nvinfer1::v_1_0::IPluginCreator;
        #[repr(C)]
        pub struct IPluginRegistry__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginRegistry {
            pub vtable_: *const IPluginRegistry__bindgen_vtable,
        }
        pub type IPluginRegistry_PluginLibraryHandle = *mut ::core::ffi::c_void;
        pub type IProgressMonitor = root::nvinfer1::v_1_0::IProgressMonitor;
        pub type IAlgorithmSelector = root::nvinfer1::v_1_0::IAlgorithmSelector;
        pub type IProfiler = root::nvinfer1::v_1_0::IProfiler;
        pub type IOutputAllocator = root::nvinfer1::v_1_0::IOutputAllocator;
        pub type IDebugListener = root::nvinfer1::v_1_0::IDebugListener;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IPlugin {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IPluginExt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IPluginFactory {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IPluginLayer {
            _unused: [u8; 0],
        }
        pub type IStreamReader = root::nvinfer1::v_1_0::IStreamReader;
        pub type IStreamReaderV2 = root::nvinfer1::v_1_0::IStreamReaderV2;
        pub type TacticSources = u32;
        pub type TensorFormats = u32;
        pub type BuilderFlags = u32;
        pub type NetworkDefinitionCreationFlags = u32;
        pub type QuantizationFlags = u32;
        pub type TempfileControlFlags = u32;
        pub type SerializationFlags = u32;
        pub mod apiv {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct VRoot__bindgen_vtable(::core::ffi::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct VRoot {
                pub vtable_: *const VRoot__bindgen_vtable,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VHostMemory {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VDimensionExpr {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VExprBuilder {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VRuntime {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VRefitter {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VOptimizationProfile {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VCudaEngine {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VExecutionContext {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VEngineInspector {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VTensor {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConvolutionLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VActivationLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VPoolingLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VLRNLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VScaleLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VSoftMaxLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConcatenationLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VDeconvolutionLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VElementWiseLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VGatherLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VPluginLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VPluginV2Layer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VPluginV3Layer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VUnaryLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VReduceLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VPaddingLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VShuffleLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VSliceLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VShapeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VTopKLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VMatrixMultiplyLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VNonZeroLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VRaggedSoftMaxLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VIdentityLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VCastLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConstantLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VParametricReLULayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VResizeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VLoopBoundaryLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VRecurrenceLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VLoopOutputLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VTripLimitLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VIteratorLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VLoop {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConditionalBoundaryLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConditionLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConditionalInputLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VConditionalOutputLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VIfConditional {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VSelectLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VAssertionLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VFillLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VQuantizeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VDequantizeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VScatterLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VEinsumLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VOneHotLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VGridSampleLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VNMSLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VReverseSequenceLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VNormalizationLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VSqueezeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VUnsqueezeLayer {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VNetworkDefinition {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VAlgorithmIOInfo {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VAlgorithmVariant {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VAlgorithmContext {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VAlgorithm {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VTimingCache {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VBuilderConfig {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VSerializationConfig {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct VBuilder {
                pub _base: root::nvinfer1::apiv::VRoot,
            }
        }
        #[repr(C)]
        pub struct INoCopy__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct INoCopy {
            pub vtable_: *const INoCopy__bindgen_vtable,
        }
        pub const EngineCapability_kSTANDARD: root::nvinfer1::EngineCapability = 0;
        pub const EngineCapability_kSAFETY: root::nvinfer1::EngineCapability = 1;
        pub const EngineCapability_kDLA_STANDALONE: root::nvinfer1::EngineCapability = 2;
        pub type EngineCapability = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Weights {
            pub type_: root::nvinfer1::DataType,
            pub values: *const ::core::ffi::c_void,
            pub count: i64,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IHostMemory {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VHostMemory,
        }
        pub const DimensionOperation_kSUM: root::nvinfer1::DimensionOperation = 0;
        pub const DimensionOperation_kPROD: root::nvinfer1::DimensionOperation = 1;
        pub const DimensionOperation_kMAX: root::nvinfer1::DimensionOperation = 2;
        pub const DimensionOperation_kMIN: root::nvinfer1::DimensionOperation = 3;
        pub const DimensionOperation_kSUB: root::nvinfer1::DimensionOperation = 4;
        pub const DimensionOperation_kEQUAL: root::nvinfer1::DimensionOperation = 5;
        pub const DimensionOperation_kLESS: root::nvinfer1::DimensionOperation = 6;
        pub const DimensionOperation_kFLOOR_DIV: root::nvinfer1::DimensionOperation = 7;
        pub const DimensionOperation_kCEIL_DIV: root::nvinfer1::DimensionOperation = 8;
        pub type DimensionOperation = i32;
        pub const TensorLocation_kDEVICE: root::nvinfer1::TensorLocation = 0;
        pub const TensorLocation_kHOST: root::nvinfer1::TensorLocation = 1;
        pub type TensorLocation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IDimensionExpr {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VDimensionExpr,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IExprBuilder {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VExprBuilder,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DimsExprs {
            pub nbDims: i32,
            pub d: [*const root::nvinfer1::IDimensionExpr; 8usize],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DynamicPluginTensorDesc {
            pub desc: root::nvinfer1::PluginTensorDesc,
            pub min: root::nvinfer1::Dims,
            pub max: root::nvinfer1::Dims,
            pub opt: root::nvinfer1::Dims,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV2DynamicExt {
            pub _base: root::nvinfer1::IPluginV2Ext,
        }
        pub const IPluginV2DynamicExt_kFORMAT_COMBINATION_LIMIT: i32 = 100;
        pub const SeekPosition_kSET: root::nvinfer1::SeekPosition = 0;
        pub const SeekPosition_kCUR: root::nvinfer1::SeekPosition = 1;
        pub const SeekPosition_kEND: root::nvinfer1::SeekPosition = 2;
        pub type SeekPosition = i32;
        #[repr(C)]
        pub struct IPluginResourceContext__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginResourceContext {
            pub vtable_: *const IPluginResourceContext__bindgen_vtable,
        }
        pub mod v_2_0 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct IPluginV3OneBuild {
                pub _base: root::nvinfer1::v_1_0::IPluginV3OneBuild,
            }
        }
        pub type IPluginV3OneCore = root::nvinfer1::v_1_0::IPluginV3OneCore;
        pub type IPluginV3OneBuild = root::nvinfer1::v_1_0::IPluginV3OneBuild;
        pub type IPluginV3OneRuntime = root::nvinfer1::v_1_0::IPluginV3OneRuntime;
        pub type IPluginV3OneBuildV2 = root::nvinfer1::v_2_0::IPluginV3OneBuild;
        pub const WeightsRole_kKERNEL: root::nvinfer1::WeightsRole = 0;
        pub const WeightsRole_kBIAS: root::nvinfer1::WeightsRole = 1;
        pub const WeightsRole_kSHIFT: root::nvinfer1::WeightsRole = 2;
        pub const WeightsRole_kSCALE: root::nvinfer1::WeightsRole = 3;
        pub const WeightsRole_kCONSTANT: root::nvinfer1::WeightsRole = 4;
        pub const WeightsRole_kANY: root::nvinfer1::WeightsRole = 5;
        pub type WeightsRole = i32;
        pub const DeviceType_kGPU: root::nvinfer1::DeviceType = 0;
        pub const DeviceType_kDLA: root::nvinfer1::DeviceType = 1;
        pub type DeviceType = i32;
        pub const TempfileControlFlag_kALLOW_IN_MEMORY_FILES: root::nvinfer1::TempfileControlFlag =
            0;
        pub const TempfileControlFlag_kALLOW_TEMPORARY_FILES: root::nvinfer1::TempfileControlFlag =
            1;
        pub type TempfileControlFlag = i32;
        pub const TensorFormat_kLINEAR: root::nvinfer1::TensorFormat = 0;
        pub const TensorFormat_kCHW2: root::nvinfer1::TensorFormat = 1;
        pub const TensorFormat_kHWC8: root::nvinfer1::TensorFormat = 2;
        pub const TensorFormat_kCHW4: root::nvinfer1::TensorFormat = 3;
        pub const TensorFormat_kCHW16: root::nvinfer1::TensorFormat = 4;
        pub const TensorFormat_kCHW32: root::nvinfer1::TensorFormat = 5;
        pub const TensorFormat_kDHWC8: root::nvinfer1::TensorFormat = 6;
        pub const TensorFormat_kCDHW32: root::nvinfer1::TensorFormat = 7;
        pub const TensorFormat_kHWC: root::nvinfer1::TensorFormat = 8;
        pub const TensorFormat_kDLA_LINEAR: root::nvinfer1::TensorFormat = 9;
        pub const TensorFormat_kDLA_HWC4: root::nvinfer1::TensorFormat = 10;
        pub const TensorFormat_kHWC16: root::nvinfer1::TensorFormat = 11;
        pub const TensorFormat_kDHWC: root::nvinfer1::TensorFormat = 12;
        pub type TensorFormat = i32;
        pub const AllocatorFlag_kRESIZABLE: root::nvinfer1::AllocatorFlag = 0;
        pub type AllocatorFlag = i32;
        pub type AllocatorFlags = u32;
        #[repr(C)]
        pub struct ILogger__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILogger {
            pub vtable_: *const ILogger__bindgen_vtable,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ILogger_Severity {
            kINTERNAL_ERROR = 0,
            kERROR = 1,
            kWARNING = 2,
            kINFO = 3,
            kVERBOSE = 4,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRuntime {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VRuntime,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRefitter {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VRefitter,
        }
        pub const OptProfileSelector_kMIN: root::nvinfer1::OptProfileSelector = 0;
        pub const OptProfileSelector_kOPT: root::nvinfer1::OptProfileSelector = 1;
        pub const OptProfileSelector_kMAX: root::nvinfer1::OptProfileSelector = 2;
        pub type OptProfileSelector = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IOptimizationProfile {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VOptimizationProfile,
        }
        pub const TacticSource_kCUBLAS: root::nvinfer1::TacticSource = 0;
        pub const TacticSource_kCUBLAS_LT: root::nvinfer1::TacticSource = 1;
        pub const TacticSource_kCUDNN: root::nvinfer1::TacticSource = 2;
        pub const TacticSource_kEDGE_MASK_CONVOLUTIONS: root::nvinfer1::TacticSource = 3;
        pub const TacticSource_kJIT_CONVOLUTIONS: root::nvinfer1::TacticSource = 4;
        pub type TacticSource = i32;
        pub const ProfilingVerbosity_kLAYER_NAMES_ONLY: root::nvinfer1::ProfilingVerbosity = 0;
        pub const ProfilingVerbosity_kNONE: root::nvinfer1::ProfilingVerbosity = 1;
        pub const ProfilingVerbosity_kDETAILED: root::nvinfer1::ProfilingVerbosity = 2;
        pub type ProfilingVerbosity = i32;
        pub const SerializationFlag_kEXCLUDE_WEIGHTS: root::nvinfer1::SerializationFlag = 0;
        pub const SerializationFlag_kEXCLUDE_LEAN_RUNTIME: root::nvinfer1::SerializationFlag = 1;
        pub type SerializationFlag = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ISerializationConfig {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VSerializationConfig,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExecutionContextAllocationStrategy {
            kSTATIC = 0,
            kON_PROFILE_CHANGE = 1,
            kUSER_MANAGED = 2,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ICudaEngine {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VCudaEngine,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IExecutionContext {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VExecutionContext,
        }
        pub const LayerInformationFormat_kONELINE: root::nvinfer1::LayerInformationFormat = 0;
        pub const LayerInformationFormat_kJSON: root::nvinfer1::LayerInformationFormat = 1;
        pub type LayerInformationFormat = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IEngineInspector {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VEngineInspector,
        }
        pub mod _bindgen_mod_id_29806 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PluginRegistrar<T> {
            pub _phantom_0: ::core::marker::PhantomData<::core::cell::UnsafeCell<T>>,
            pub instance: T,
        }
        #[repr(C)]
        pub struct ILoggerFinder__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILoggerFinder {
            pub vtable_: *const ILoggerFinder__bindgen_vtable,
        }
        pub type IGpuAsyncAllocator = root::nvinfer1::v_1_0::IGpuAsyncAllocator;
        pub type IPluginCreatorV3One = root::nvinfer1::v_1_0::IPluginCreatorV3One;
        pub const LayerType_kCONVOLUTION: root::nvinfer1::LayerType = 0;
        pub const LayerType_kCAST: root::nvinfer1::LayerType = 1;
        pub const LayerType_kACTIVATION: root::nvinfer1::LayerType = 2;
        pub const LayerType_kPOOLING: root::nvinfer1::LayerType = 3;
        pub const LayerType_kLRN: root::nvinfer1::LayerType = 4;
        pub const LayerType_kSCALE: root::nvinfer1::LayerType = 5;
        pub const LayerType_kSOFTMAX: root::nvinfer1::LayerType = 6;
        pub const LayerType_kDECONVOLUTION: root::nvinfer1::LayerType = 7;
        pub const LayerType_kCONCATENATION: root::nvinfer1::LayerType = 8;
        pub const LayerType_kELEMENTWISE: root::nvinfer1::LayerType = 9;
        pub const LayerType_kPLUGIN: root::nvinfer1::LayerType = 10;
        pub const LayerType_kUNARY: root::nvinfer1::LayerType = 11;
        pub const LayerType_kPADDING: root::nvinfer1::LayerType = 12;
        pub const LayerType_kSHUFFLE: root::nvinfer1::LayerType = 13;
        pub const LayerType_kREDUCE: root::nvinfer1::LayerType = 14;
        pub const LayerType_kTOPK: root::nvinfer1::LayerType = 15;
        pub const LayerType_kGATHER: root::nvinfer1::LayerType = 16;
        pub const LayerType_kMATRIX_MULTIPLY: root::nvinfer1::LayerType = 17;
        pub const LayerType_kRAGGED_SOFTMAX: root::nvinfer1::LayerType = 18;
        pub const LayerType_kCONSTANT: root::nvinfer1::LayerType = 19;
        pub const LayerType_kIDENTITY: root::nvinfer1::LayerType = 20;
        pub const LayerType_kPLUGIN_V2: root::nvinfer1::LayerType = 21;
        pub const LayerType_kSLICE: root::nvinfer1::LayerType = 22;
        pub const LayerType_kSHAPE: root::nvinfer1::LayerType = 23;
        pub const LayerType_kPARAMETRIC_RELU: root::nvinfer1::LayerType = 24;
        pub const LayerType_kRESIZE: root::nvinfer1::LayerType = 25;
        pub const LayerType_kTRIP_LIMIT: root::nvinfer1::LayerType = 26;
        pub const LayerType_kRECURRENCE: root::nvinfer1::LayerType = 27;
        pub const LayerType_kITERATOR: root::nvinfer1::LayerType = 28;
        pub const LayerType_kLOOP_OUTPUT: root::nvinfer1::LayerType = 29;
        pub const LayerType_kSELECT: root::nvinfer1::LayerType = 30;
        pub const LayerType_kFILL: root::nvinfer1::LayerType = 31;
        pub const LayerType_kQUANTIZE: root::nvinfer1::LayerType = 32;
        pub const LayerType_kDEQUANTIZE: root::nvinfer1::LayerType = 33;
        pub const LayerType_kCONDITION: root::nvinfer1::LayerType = 34;
        pub const LayerType_kCONDITIONAL_INPUT: root::nvinfer1::LayerType = 35;
        pub const LayerType_kCONDITIONAL_OUTPUT: root::nvinfer1::LayerType = 36;
        pub const LayerType_kSCATTER: root::nvinfer1::LayerType = 37;
        pub const LayerType_kEINSUM: root::nvinfer1::LayerType = 38;
        pub const LayerType_kASSERTION: root::nvinfer1::LayerType = 39;
        pub const LayerType_kONE_HOT: root::nvinfer1::LayerType = 40;
        pub const LayerType_kNON_ZERO: root::nvinfer1::LayerType = 41;
        pub const LayerType_kGRID_SAMPLE: root::nvinfer1::LayerType = 42;
        pub const LayerType_kNMS: root::nvinfer1::LayerType = 43;
        pub const LayerType_kREVERSE_SEQUENCE: root::nvinfer1::LayerType = 44;
        pub const LayerType_kNORMALIZATION: root::nvinfer1::LayerType = 45;
        pub const LayerType_kPLUGIN_V3: root::nvinfer1::LayerType = 46;
        pub const LayerType_kSQUEEZE: root::nvinfer1::LayerType = 47;
        pub const LayerType_kUNSQUEEZE: root::nvinfer1::LayerType = 48;
        pub type LayerType = i32;
        pub const ActivationType_kRELU: root::nvinfer1::ActivationType = 0;
        pub const ActivationType_kSIGMOID: root::nvinfer1::ActivationType = 1;
        pub const ActivationType_kTANH: root::nvinfer1::ActivationType = 2;
        pub const ActivationType_kLEAKY_RELU: root::nvinfer1::ActivationType = 3;
        pub const ActivationType_kELU: root::nvinfer1::ActivationType = 4;
        pub const ActivationType_kSELU: root::nvinfer1::ActivationType = 5;
        pub const ActivationType_kSOFTSIGN: root::nvinfer1::ActivationType = 6;
        pub const ActivationType_kSOFTPLUS: root::nvinfer1::ActivationType = 7;
        pub const ActivationType_kCLIP: root::nvinfer1::ActivationType = 8;
        pub const ActivationType_kHARD_SIGMOID: root::nvinfer1::ActivationType = 9;
        pub const ActivationType_kSCALED_TANH: root::nvinfer1::ActivationType = 10;
        pub const ActivationType_kTHRESHOLDED_RELU: root::nvinfer1::ActivationType = 11;
        pub const ActivationType_kGELU_ERF: root::nvinfer1::ActivationType = 12;
        pub const ActivationType_kGELU_TANH: root::nvinfer1::ActivationType = 13;
        pub type ActivationType = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ITensor {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VTensor,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILayer {
            pub _base: root::nvinfer1::INoCopy,
            pub mLayer: *mut root::nvinfer1::apiv::VLayer,
        }
        pub const PaddingMode_kEXPLICIT_ROUND_DOWN: root::nvinfer1::PaddingMode = 0;
        pub const PaddingMode_kEXPLICIT_ROUND_UP: root::nvinfer1::PaddingMode = 1;
        pub const PaddingMode_kSAME_UPPER: root::nvinfer1::PaddingMode = 2;
        pub const PaddingMode_kSAME_LOWER: root::nvinfer1::PaddingMode = 3;
        pub type PaddingMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IConvolutionLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConvolutionLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IActivationLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VActivationLayer,
        }
        pub const PoolingType_kMAX: root::nvinfer1::PoolingType = 0;
        pub const PoolingType_kAVERAGE: root::nvinfer1::PoolingType = 1;
        pub const PoolingType_kMAX_AVERAGE_BLEND: root::nvinfer1::PoolingType = 2;
        pub type PoolingType = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPoolingLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VPoolingLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILRNLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VLRNLayer,
        }
        pub const ScaleMode_kUNIFORM: root::nvinfer1::ScaleMode = 0;
        pub const ScaleMode_kCHANNEL: root::nvinfer1::ScaleMode = 1;
        pub const ScaleMode_kELEMENTWISE: root::nvinfer1::ScaleMode = 2;
        pub type ScaleMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IScaleLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VScaleLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ISoftMaxLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VSoftMaxLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IConcatenationLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConcatenationLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IDeconvolutionLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VDeconvolutionLayer,
        }
        pub const ElementWiseOperation_kSUM: root::nvinfer1::ElementWiseOperation = 0;
        pub const ElementWiseOperation_kPROD: root::nvinfer1::ElementWiseOperation = 1;
        pub const ElementWiseOperation_kMAX: root::nvinfer1::ElementWiseOperation = 2;
        pub const ElementWiseOperation_kMIN: root::nvinfer1::ElementWiseOperation = 3;
        pub const ElementWiseOperation_kSUB: root::nvinfer1::ElementWiseOperation = 4;
        pub const ElementWiseOperation_kDIV: root::nvinfer1::ElementWiseOperation = 5;
        pub const ElementWiseOperation_kPOW: root::nvinfer1::ElementWiseOperation = 6;
        pub const ElementWiseOperation_kFLOOR_DIV: root::nvinfer1::ElementWiseOperation = 7;
        pub const ElementWiseOperation_kAND: root::nvinfer1::ElementWiseOperation = 8;
        pub const ElementWiseOperation_kOR: root::nvinfer1::ElementWiseOperation = 9;
        pub const ElementWiseOperation_kXOR: root::nvinfer1::ElementWiseOperation = 10;
        pub const ElementWiseOperation_kEQUAL: root::nvinfer1::ElementWiseOperation = 11;
        pub const ElementWiseOperation_kGREATER: root::nvinfer1::ElementWiseOperation = 12;
        pub const ElementWiseOperation_kLESS: root::nvinfer1::ElementWiseOperation = 13;
        pub type ElementWiseOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IElementWiseLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VElementWiseLayer,
        }
        pub const GatherMode_kDEFAULT: root::nvinfer1::GatherMode = 0;
        pub const GatherMode_kELEMENT: root::nvinfer1::GatherMode = 1;
        pub const GatherMode_kND: root::nvinfer1::GatherMode = 2;
        pub type GatherMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IGatherLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VGatherLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV2Layer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VPluginV2Layer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPluginV3Layer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VPluginV3Layer,
        }
        pub const UnaryOperation_kEXP: root::nvinfer1::UnaryOperation = 0;
        pub const UnaryOperation_kLOG: root::nvinfer1::UnaryOperation = 1;
        pub const UnaryOperation_kSQRT: root::nvinfer1::UnaryOperation = 2;
        pub const UnaryOperation_kRECIP: root::nvinfer1::UnaryOperation = 3;
        pub const UnaryOperation_kABS: root::nvinfer1::UnaryOperation = 4;
        pub const UnaryOperation_kNEG: root::nvinfer1::UnaryOperation = 5;
        pub const UnaryOperation_kSIN: root::nvinfer1::UnaryOperation = 6;
        pub const UnaryOperation_kCOS: root::nvinfer1::UnaryOperation = 7;
        pub const UnaryOperation_kTAN: root::nvinfer1::UnaryOperation = 8;
        pub const UnaryOperation_kSINH: root::nvinfer1::UnaryOperation = 9;
        pub const UnaryOperation_kCOSH: root::nvinfer1::UnaryOperation = 10;
        pub const UnaryOperation_kASIN: root::nvinfer1::UnaryOperation = 11;
        pub const UnaryOperation_kACOS: root::nvinfer1::UnaryOperation = 12;
        pub const UnaryOperation_kATAN: root::nvinfer1::UnaryOperation = 13;
        pub const UnaryOperation_kASINH: root::nvinfer1::UnaryOperation = 14;
        pub const UnaryOperation_kACOSH: root::nvinfer1::UnaryOperation = 15;
        pub const UnaryOperation_kATANH: root::nvinfer1::UnaryOperation = 16;
        pub const UnaryOperation_kCEIL: root::nvinfer1::UnaryOperation = 17;
        pub const UnaryOperation_kFLOOR: root::nvinfer1::UnaryOperation = 18;
        pub const UnaryOperation_kERF: root::nvinfer1::UnaryOperation = 19;
        pub const UnaryOperation_kNOT: root::nvinfer1::UnaryOperation = 20;
        pub const UnaryOperation_kSIGN: root::nvinfer1::UnaryOperation = 21;
        pub const UnaryOperation_kROUND: root::nvinfer1::UnaryOperation = 22;
        pub const UnaryOperation_kISINF: root::nvinfer1::UnaryOperation = 23;
        pub const UnaryOperation_kISNAN: root::nvinfer1::UnaryOperation = 24;
        pub type UnaryOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IUnaryLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VUnaryLayer,
        }
        pub const ReduceOperation_kSUM: root::nvinfer1::ReduceOperation = 0;
        pub const ReduceOperation_kPROD: root::nvinfer1::ReduceOperation = 1;
        pub const ReduceOperation_kMAX: root::nvinfer1::ReduceOperation = 2;
        pub const ReduceOperation_kMIN: root::nvinfer1::ReduceOperation = 3;
        pub const ReduceOperation_kAVG: root::nvinfer1::ReduceOperation = 4;
        pub type ReduceOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IReduceLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VReduceLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IPaddingLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VPaddingLayer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Permutation {
            pub order: [i32; 8usize],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IShuffleLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VShuffleLayer,
        }
        pub const SampleMode_kSTRICT_BOUNDS: root::nvinfer1::SampleMode = 0;
        pub const SampleMode_kWRAP: root::nvinfer1::SampleMode = 1;
        pub const SampleMode_kCLAMP: root::nvinfer1::SampleMode = 2;
        pub const SampleMode_kFILL: root::nvinfer1::SampleMode = 3;
        pub const SampleMode_kREFLECT: root::nvinfer1::SampleMode = 4;
        pub type SampleMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ISliceLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VSliceLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IShapeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VShapeLayer,
        }
        pub const TopKOperation_kMAX: root::nvinfer1::TopKOperation = 0;
        pub const TopKOperation_kMIN: root::nvinfer1::TopKOperation = 1;
        pub type TopKOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ITopKLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VTopKLayer,
        }
        pub const MatrixOperation_kNONE: root::nvinfer1::MatrixOperation = 0;
        pub const MatrixOperation_kTRANSPOSE: root::nvinfer1::MatrixOperation = 1;
        pub const MatrixOperation_kVECTOR: root::nvinfer1::MatrixOperation = 2;
        pub type MatrixOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IMatrixMultiplyLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VMatrixMultiplyLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct INonZeroLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VNonZeroLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRaggedSoftMaxLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VRaggedSoftMaxLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIdentityLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VIdentityLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ICastLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VCastLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IConstantLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConstantLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IParametricReLULayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VParametricReLULayer,
        }
        pub const InterpolationMode_kNEAREST: root::nvinfer1::InterpolationMode = 0;
        pub const InterpolationMode_kLINEAR: root::nvinfer1::InterpolationMode = 1;
        pub const InterpolationMode_kCUBIC: root::nvinfer1::InterpolationMode = 2;
        pub type InterpolationMode = i32;
        pub const ResizeCoordinateTransformation_kALIGN_CORNERS:
            root::nvinfer1::ResizeCoordinateTransformation = 0;
        pub const ResizeCoordinateTransformation_kASYMMETRIC:
            root::nvinfer1::ResizeCoordinateTransformation = 1;
        pub const ResizeCoordinateTransformation_kHALF_PIXEL:
            root::nvinfer1::ResizeCoordinateTransformation = 2;
        pub type ResizeCoordinateTransformation = i32;
        pub const ResizeSelector_kFORMULA: root::nvinfer1::ResizeSelector = 0;
        pub const ResizeSelector_kUPPER: root::nvinfer1::ResizeSelector = 1;
        pub type ResizeSelector = i32;
        pub const ResizeRoundMode_kHALF_UP: root::nvinfer1::ResizeRoundMode = 0;
        pub const ResizeRoundMode_kHALF_DOWN: root::nvinfer1::ResizeRoundMode = 1;
        pub const ResizeRoundMode_kFLOOR: root::nvinfer1::ResizeRoundMode = 2;
        pub const ResizeRoundMode_kCEIL: root::nvinfer1::ResizeRoundMode = 3;
        pub type ResizeRoundMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IResizeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VResizeLayer,
        }
        pub const LoopOutput_kLAST_VALUE: root::nvinfer1::LoopOutput = 0;
        pub const LoopOutput_kCONCATENATE: root::nvinfer1::LoopOutput = 1;
        pub const LoopOutput_kREVERSE: root::nvinfer1::LoopOutput = 2;
        pub type LoopOutput = i32;
        pub const TripLimit_kCOUNT: root::nvinfer1::TripLimit = 0;
        pub const TripLimit_kWHILE: root::nvinfer1::TripLimit = 1;
        pub type TripLimit = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILoopBoundaryLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mBoundary: *mut root::nvinfer1::apiv::VLoopBoundaryLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIfConditionalBoundaryLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mBoundary: *mut root::nvinfer1::apiv::VConditionalBoundaryLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IConditionLayer {
            pub _base: root::nvinfer1::IIfConditionalBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConditionLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIfConditionalOutputLayer {
            pub _base: root::nvinfer1::IIfConditionalBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConditionalOutputLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIfConditionalInputLayer {
            pub _base: root::nvinfer1::IIfConditionalBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VConditionalInputLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIfConditional {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VIfConditional,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRecurrenceLayer {
            pub _base: root::nvinfer1::ILoopBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VRecurrenceLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILoopOutputLayer {
            pub _base: root::nvinfer1::ILoopBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VLoopOutputLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ITripLimitLayer {
            pub _base: root::nvinfer1::ILoopBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VTripLimitLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IIteratorLayer {
            pub _base: root::nvinfer1::ILoopBoundaryLayer,
            pub mImpl: *mut root::nvinfer1::apiv::VIteratorLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ILoop {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VLoop,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ISelectLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VSelectLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAssertionLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VAssertionLayer,
        }
        pub const FillOperation_kLINSPACE: root::nvinfer1::FillOperation = 0;
        pub const FillOperation_kRANDOM_UNIFORM: root::nvinfer1::FillOperation = 1;
        pub const FillOperation_kRANDOM_NORMAL: root::nvinfer1::FillOperation = 2;
        pub type FillOperation = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IFillLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VFillLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IQuantizeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VQuantizeLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IDequantizeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VDequantizeLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IEinsumLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VEinsumLayer,
        }
        pub const ScatterMode_kELEMENT: root::nvinfer1::ScatterMode = 0;
        pub const ScatterMode_kND: root::nvinfer1::ScatterMode = 1;
        pub type ScatterMode = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IScatterLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VScatterLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IOneHotLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VOneHotLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IGridSampleLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VGridSampleLayer,
        }
        pub const BoundingBoxFormat_kCORNER_PAIRS: root::nvinfer1::BoundingBoxFormat = 0;
        pub const BoundingBoxFormat_kCENTER_SIZES: root::nvinfer1::BoundingBoxFormat = 1;
        pub type BoundingBoxFormat = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct INMSLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VNMSLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IReverseSequenceLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VReverseSequenceLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct INormalizationLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VNormalizationLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ISqueezeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VSqueezeLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IUnsqueezeLayer {
            pub _base: root::nvinfer1::ILayer,
            pub mImpl: *mut root::nvinfer1::apiv::VUnsqueezeLayer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct INetworkDefinition {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VNetworkDefinition,
        }
        pub const CalibrationAlgoType_kLEGACY_CALIBRATION: root::nvinfer1::CalibrationAlgoType = 0;
        pub const CalibrationAlgoType_kENTROPY_CALIBRATION: root::nvinfer1::CalibrationAlgoType = 1;
        pub const CalibrationAlgoType_kENTROPY_CALIBRATION_2: root::nvinfer1::CalibrationAlgoType =
            2;
        pub const CalibrationAlgoType_kMINMAX_CALIBRATION: root::nvinfer1::CalibrationAlgoType = 3;
        pub type CalibrationAlgoType = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IInt8Calibrator {
            pub _base: root::nvinfer1::IVersionedInterface,
        }
        pub type IInt8EntropyCalibrator = root::nvinfer1::v_1_0::IInt8EntropyCalibrator;
        pub type IInt8EntropyCalibrator2 = root::nvinfer1::v_1_0::IInt8EntropyCalibrator2;
        pub type IInt8MinMaxCalibrator = root::nvinfer1::v_1_0::IInt8MinMaxCalibrator;
        pub type IInt8LegacyCalibrator = root::nvinfer1::v_1_0::IInt8LegacyCalibrator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAlgorithmIOInfo {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VAlgorithmIOInfo,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAlgorithmVariant {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VAlgorithmVariant,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAlgorithmContext {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VAlgorithmContext,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAlgorithm {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VAlgorithm,
        }
        pub const QuantizationFlag_kCALIBRATE_BEFORE_FUSION: root::nvinfer1::QuantizationFlag = 0;
        pub type QuantizationFlag = i32;
        pub const RuntimePlatform_kSAME_AS_BUILD: root::nvinfer1::RuntimePlatform = 0;
        pub const RuntimePlatform_kWINDOWS_AMD64: root::nvinfer1::RuntimePlatform = 1;
        pub type RuntimePlatform = i32;
        impl root::nvinfer1::BuilderFlag {
            pub const kWEIGHTLESS: root::nvinfer1::BuilderFlag = BuilderFlag::kSTRIP_PLAN;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BuilderFlag {
            kFP16 = 0,
            kINT8 = 1,
            kDEBUG = 2,
            kGPU_FALLBACK = 3,
            kREFIT = 4,
            kDISABLE_TIMING_CACHE = 5,
            kTF32 = 6,
            kSPARSE_WEIGHTS = 7,
            kSAFETY_SCOPE = 8,
            kOBEY_PRECISION_CONSTRAINTS = 9,
            kPREFER_PRECISION_CONSTRAINTS = 10,
            kDIRECT_IO = 11,
            kREJECT_EMPTY_ALGORITHMS = 12,
            kVERSION_COMPATIBLE = 13,
            kEXCLUDE_LEAN_RUNTIME = 14,
            kFP8 = 15,
            kERROR_ON_TIMING_CACHE_MISS = 16,
            kBF16 = 17,
            kDISABLE_COMPILATION_CACHE = 18,
            kSTRIP_PLAN = 19,
            kREFIT_IDENTICAL = 20,
            kWEIGHT_STREAMING = 21,
            kINT4 = 22,
            kREFIT_INDIVIDUAL = 23,
            kSTRICT_NANS = 24,
            kMONITOR_MEMORY = 25,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ITimingCache {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VTimingCache,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryPoolType {
            kWORKSPACE = 0,
            kDLA_MANAGED_SRAM = 1,
            kDLA_LOCAL_DRAM = 2,
            kDLA_GLOBAL_DRAM = 3,
            kTACTIC_DRAM = 4,
            kTACTIC_SHARED_MEMORY = 5,
        }
        pub const PreviewFeature_kPROFILE_SHARING_0806: root::nvinfer1::PreviewFeature = 0;
        pub const PreviewFeature_kALIASED_PLUGIN_IO_10_03: root::nvinfer1::PreviewFeature = 1;
        pub type PreviewFeature = i32;
        pub const HardwareCompatibilityLevel_kNONE: root::nvinfer1::HardwareCompatibilityLevel = 0;
        pub const HardwareCompatibilityLevel_kAMPERE_PLUS:
            root::nvinfer1::HardwareCompatibilityLevel = 1;
        pub type HardwareCompatibilityLevel = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IBuilderConfig {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VBuilderConfig,
        }
        pub const NetworkDefinitionCreationFlag_kEXPLICIT_BATCH:
            root::nvinfer1::NetworkDefinitionCreationFlag = 0;
        pub const NetworkDefinitionCreationFlag_kSTRONGLY_TYPED:
            root::nvinfer1::NetworkDefinitionCreationFlag = 1;
        pub type NetworkDefinitionCreationFlag = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IBuilder {
            pub _base: root::nvinfer1::INoCopy,
            pub mImpl: *mut root::nvinfer1::apiv::VBuilder,
        }
        pub mod safe {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IPluginRegistry {
                _unused: [u8; 0],
            }
        }
        pub const TENSORRT_VERSION: i32 = 100700;
        pub const ONNX_PARSER_VERSION: i32 = 100;
        unsafe extern "C" {
            pub fn getBuilderPluginRegistry(
                capability: root::nvinfer1::EngineCapability,
            ) -> *mut root::nvinfer1::IPluginRegistry;
            pub fn getBuilderSafePluginRegistry(
                capability: root::nvinfer1::EngineCapability,
            ) -> *mut root::nvinfer1::safe::IPluginRegistry;
        }
    }
    pub type SubGraph_t = u8;
    pub type SubGraphCollection_t = u8;
    pub mod nvonnxparser {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorCode {
            kSUCCESS = 0,
            kINTERNAL_ERROR = 1,
            kMEM_ALLOC_FAILED = 2,
            kMODEL_DESERIALIZE_FAILED = 3,
            kINVALID_VALUE = 4,
            kINVALID_GRAPH = 5,
            kINVALID_NODE = 6,
            kUNSUPPORTED_GRAPH = 7,
            kUNSUPPORTED_NODE = 8,
            kUNSUPPORTED_NODE_ATTR = 9,
            kUNSUPPORTED_NODE_INPUT = 10,
            kUNSUPPORTED_NODE_DATATYPE = 11,
            kUNSUPPORTED_NODE_DYNAMIC = 12,
            kUNSUPPORTED_NODE_SHAPE = 13,
            kREFIT_FAILED = 14,
        }
        pub type OnnxParserFlags = u32;
        pub const OnnxParserFlag_kNATIVE_INSTANCENORM: root::nvonnxparser::OnnxParserFlag = 0;
        pub type OnnxParserFlag = i32;
        #[repr(C)]
        pub struct IParserError__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IParserError {
            pub vtable_: *const IParserError__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IParser__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IParser {
            pub vtable_: *const IParser__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IParserRefitter__bindgen_vtable(::core::ffi::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IParserRefitter {
            pub vtable_: *const IParserRefitter__bindgen_vtable,
        }
        pub mod _bindgen_mod_id_93854 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    unsafe extern "C" {
        pub fn cudaDeviceReset() -> root::cudaError_t;
        pub fn cudaDeviceSynchronize() -> root::cudaError_t;
        pub fn cudaDeviceSetLimit(limit: root::cudaLimit, value: usize) -> root::cudaError_t;
        pub fn cudaDeviceGetLimit(pValue: *mut usize, limit: root::cudaLimit) -> root::cudaError_t;
        pub fn cudaDeviceGetTexture1DLinearMaxWidth(
            maxWidthInElements: *mut usize,
            fmtDesc: *const root::cudaChannelFormatDesc,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetCacheConfig(
            pCacheConfig: *mut root::cudaFuncCache,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetStreamPriorityRange(
            leastPriority: *mut ::core::ffi::c_int,
            greatestPriority: *mut ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceSetCacheConfig(cacheConfig: root::cudaFuncCache) -> root::cudaError_t;
        pub fn cudaDeviceGetByPCIBusId(
            device: *mut ::core::ffi::c_int,
            pciBusId: *const ::core::ffi::c_char,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetPCIBusId(
            pciBusId: *mut ::core::ffi::c_char,
            len: ::core::ffi::c_int,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaIpcGetEventHandle(
            handle: *mut root::cudaIpcEventHandle_t,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaIpcOpenEventHandle(
            event: *mut root::cudaEvent_t,
            handle: root::cudaIpcEventHandle_t,
        ) -> root::cudaError_t;
        pub fn cudaIpcGetMemHandle(
            handle: *mut root::cudaIpcMemHandle_t,
            devPtr: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaIpcOpenMemHandle(
            devPtr: *mut *mut ::core::ffi::c_void,
            handle: root::cudaIpcMemHandle_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaIpcCloseMemHandle(devPtr: *mut ::core::ffi::c_void) -> root::cudaError_t;
        pub fn cudaDeviceFlushGPUDirectRDMAWrites(
            target: root::cudaFlushGPUDirectRDMAWritesTarget,
            scope: root::cudaFlushGPUDirectRDMAWritesScope,
        ) -> root::cudaError_t;
        pub fn cudaDeviceRegisterAsyncNotification(
            device: ::core::ffi::c_int,
            callbackFunc: root::cudaAsyncCallback,
            userData: *mut ::core::ffi::c_void,
            callback: *mut root::cudaAsyncCallbackHandle_t,
        ) -> root::cudaError_t;
        pub fn cudaDeviceUnregisterAsyncNotification(
            device: ::core::ffi::c_int,
            callback: root::cudaAsyncCallbackHandle_t,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetSharedMemConfig(
            pConfig: *mut root::cudaSharedMemConfig,
        ) -> root::cudaError_t;
        pub fn cudaDeviceSetSharedMemConfig(config: root::cudaSharedMemConfig)
            -> root::cudaError_t;
        pub fn cudaThreadExit() -> root::cudaError_t;
        pub fn cudaThreadSynchronize() -> root::cudaError_t;
        pub fn cudaThreadSetLimit(limit: root::cudaLimit, value: usize) -> root::cudaError_t;
        pub fn cudaThreadGetLimit(pValue: *mut usize, limit: root::cudaLimit) -> root::cudaError_t;
        pub fn cudaThreadGetCacheConfig(
            pCacheConfig: *mut root::cudaFuncCache,
        ) -> root::cudaError_t;
        pub fn cudaThreadSetCacheConfig(cacheConfig: root::cudaFuncCache) -> root::cudaError_t;
        pub fn cudaGetLastError() -> root::cudaError_t;
        pub fn cudaPeekAtLastError() -> root::cudaError_t;
        pub fn cudaGetErrorName(error: root::cudaError_t) -> *const ::core::ffi::c_char;
        pub fn cudaGetErrorString(error: root::cudaError_t) -> *const ::core::ffi::c_char;
        pub fn cudaGetDeviceCount(count: *mut ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaGetDeviceProperties_v2(
            prop: *mut root::cudaDeviceProp,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetAttribute(
            value: *mut ::core::ffi::c_int,
            attr: root::cudaDeviceAttr,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetDefaultMemPool(
            memPool: *mut root::cudaMemPool_t,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceSetMemPool(
            device: ::core::ffi::c_int,
            memPool: root::cudaMemPool_t,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetMemPool(
            memPool: *mut root::cudaMemPool_t,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetNvSciSyncAttributes(
            nvSciSyncAttrList: *mut ::core::ffi::c_void,
            device: ::core::ffi::c_int,
            flags: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGetP2PAttribute(
            value: *mut ::core::ffi::c_int,
            attr: root::cudaDeviceP2PAttr,
            srcDevice: ::core::ffi::c_int,
            dstDevice: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaChooseDevice(
            device: *mut ::core::ffi::c_int,
            prop: *const root::cudaDeviceProp,
        ) -> root::cudaError_t;
        pub fn cudaInitDevice(
            device: ::core::ffi::c_int,
            deviceFlags: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaSetDevice(device: ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaGetDevice(device: *mut ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaSetValidDevices(
            device_arr: *mut ::core::ffi::c_int,
            len: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaSetDeviceFlags(flags: ::core::ffi::c_uint) -> root::cudaError_t;
        pub fn cudaGetDeviceFlags(flags: *mut ::core::ffi::c_uint) -> root::cudaError_t;
        pub fn cudaStreamCreate(pStream: *mut root::cudaStream_t) -> root::cudaError_t;
        pub fn cudaStreamCreateWithFlags(
            pStream: *mut root::cudaStream_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamCreateWithPriority(
            pStream: *mut root::cudaStream_t,
            flags: ::core::ffi::c_uint,
            priority: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetPriority(
            hStream: root::cudaStream_t,
            priority: *mut ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetFlags(
            hStream: root::cudaStream_t,
            flags: *mut ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetId(
            hStream: root::cudaStream_t,
            streamId: *mut ::core::ffi::c_ulonglong,
        ) -> root::cudaError_t;
        pub fn cudaCtxResetPersistingL2Cache() -> root::cudaError_t;
        pub fn cudaStreamCopyAttributes(
            dst: root::cudaStream_t,
            src: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetAttribute(
            hStream: root::cudaStream_t,
            attr: root::cudaLaunchAttributeID,
            value_out: *mut root::cudaLaunchAttributeValue,
        ) -> root::cudaError_t;
        pub fn cudaStreamSetAttribute(
            hStream: root::cudaStream_t,
            attr: root::cudaLaunchAttributeID,
            value: *const root::cudaLaunchAttributeValue,
        ) -> root::cudaError_t;
        pub fn cudaStreamDestroy(stream: root::cudaStream_t) -> root::cudaError_t;
        pub fn cudaStreamWaitEvent(
            stream: root::cudaStream_t,
            event: root::cudaEvent_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamAddCallback(
            stream: root::cudaStream_t,
            callback: root::cudaStreamCallback_t,
            userData: *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamSynchronize(stream: root::cudaStream_t) -> root::cudaError_t;
        pub fn cudaStreamQuery(stream: root::cudaStream_t) -> root::cudaError_t;
        pub fn cudaStreamAttachMemAsync(
            stream: root::cudaStream_t,
            devPtr: *mut ::core::ffi::c_void,
            length: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamBeginCapture(
            stream: root::cudaStream_t,
            mode: root::cudaStreamCaptureMode,
        ) -> root::cudaError_t;
        pub fn cudaStreamBeginCaptureToGraph(
            stream: root::cudaStream_t,
            graph: root::cudaGraph_t,
            dependencies: *const root::cudaGraphNode_t,
            dependencyData: *const root::cudaGraphEdgeData,
            numDependencies: usize,
            mode: root::cudaStreamCaptureMode,
        ) -> root::cudaError_t;
        pub fn cudaThreadExchangeStreamCaptureMode(
            mode: *mut root::cudaStreamCaptureMode,
        ) -> root::cudaError_t;
        pub fn cudaStreamEndCapture(
            stream: root::cudaStream_t,
            pGraph: *mut root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaStreamIsCapturing(
            stream: root::cudaStream_t,
            pCaptureStatus: *mut root::cudaStreamCaptureStatus,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetCaptureInfo_v2(
            stream: root::cudaStream_t,
            captureStatus_out: *mut root::cudaStreamCaptureStatus,
            id_out: *mut ::core::ffi::c_ulonglong,
            graph_out: *mut root::cudaGraph_t,
            dependencies_out: *mut *const root::cudaGraphNode_t,
            numDependencies_out: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaStreamGetCaptureInfo_v3(
            stream: root::cudaStream_t,
            captureStatus_out: *mut root::cudaStreamCaptureStatus,
            id_out: *mut ::core::ffi::c_ulonglong,
            graph_out: *mut root::cudaGraph_t,
            dependencies_out: *mut *const root::cudaGraphNode_t,
            edgeData_out: *mut *const root::cudaGraphEdgeData,
            numDependencies_out: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaStreamUpdateCaptureDependencies(
            stream: root::cudaStream_t,
            dependencies: *mut root::cudaGraphNode_t,
            numDependencies: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaStreamUpdateCaptureDependencies_v2(
            stream: root::cudaStream_t,
            dependencies: *mut root::cudaGraphNode_t,
            dependencyData: *const root::cudaGraphEdgeData,
            numDependencies: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaEventCreate(event: *mut root::cudaEvent_t) -> root::cudaError_t;
        pub fn cudaEventCreateWithFlags(
            event: *mut root::cudaEvent_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaEventRecord(
            event: root::cudaEvent_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaEventRecordWithFlags(
            event: root::cudaEvent_t,
            stream: root::cudaStream_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaEventQuery(event: root::cudaEvent_t) -> root::cudaError_t;
        pub fn cudaEventSynchronize(event: root::cudaEvent_t) -> root::cudaError_t;
        pub fn cudaEventDestroy(event: root::cudaEvent_t) -> root::cudaError_t;
        pub fn cudaEventElapsedTime(
            ms: *mut f32,
            start: root::cudaEvent_t,
            end: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaImportExternalMemory(
            extMem_out: *mut root::cudaExternalMemory_t,
            memHandleDesc: *const root::cudaExternalMemoryHandleDesc,
        ) -> root::cudaError_t;
        pub fn cudaExternalMemoryGetMappedBuffer(
            devPtr: *mut *mut ::core::ffi::c_void,
            extMem: root::cudaExternalMemory_t,
            bufferDesc: *const root::cudaExternalMemoryBufferDesc,
        ) -> root::cudaError_t;
        pub fn cudaExternalMemoryGetMappedMipmappedArray(
            mipmap: *mut root::cudaMipmappedArray_t,
            extMem: root::cudaExternalMemory_t,
            mipmapDesc: *const root::cudaExternalMemoryMipmappedArrayDesc,
        ) -> root::cudaError_t;
        pub fn cudaDestroyExternalMemory(extMem: root::cudaExternalMemory_t) -> root::cudaError_t;
        pub fn cudaImportExternalSemaphore(
            extSem_out: *mut root::cudaExternalSemaphore_t,
            semHandleDesc: *const root::cudaExternalSemaphoreHandleDesc,
        ) -> root::cudaError_t;
        pub fn cudaSignalExternalSemaphoresAsync_v2(
            extSemArray: *const root::cudaExternalSemaphore_t,
            paramsArray: *const root::cudaExternalSemaphoreSignalParams,
            numExtSems: ::core::ffi::c_uint,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaWaitExternalSemaphoresAsync_v2(
            extSemArray: *const root::cudaExternalSemaphore_t,
            paramsArray: *const root::cudaExternalSemaphoreWaitParams,
            numExtSems: ::core::ffi::c_uint,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaDestroyExternalSemaphore(
            extSem: root::cudaExternalSemaphore_t,
        ) -> root::cudaError_t;
        pub fn cudaLaunchKernel(
            func: *const ::core::ffi::c_void,
            gridDim: root::dim3,
            blockDim: root::dim3,
            args: *mut *mut ::core::ffi::c_void,
            sharedMem: usize,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaLaunchKernelExC(
            config: *const root::cudaLaunchConfig_t,
            func: *const ::core::ffi::c_void,
            args: *mut *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaLaunchCooperativeKernel(
            func: *const ::core::ffi::c_void,
            gridDim: root::dim3,
            blockDim: root::dim3,
            args: *mut *mut ::core::ffi::c_void,
            sharedMem: usize,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaLaunchCooperativeKernelMultiDevice(
            launchParamsList: *mut root::cudaLaunchParams,
            numDevices: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaFuncSetCacheConfig(
            func: *const ::core::ffi::c_void,
            cacheConfig: root::cudaFuncCache,
        ) -> root::cudaError_t;
        pub fn cudaFuncGetAttributes(
            attr: *mut root::cudaFuncAttributes,
            func: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaFuncSetAttribute(
            func: *const ::core::ffi::c_void,
            attr: root::cudaFuncAttribute,
            value: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaFuncGetName(
            name: *mut *const ::core::ffi::c_char,
            func: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaFuncGetParamInfo(
            func: *const ::core::ffi::c_void,
            paramIndex: usize,
            paramOffset: *mut usize,
            paramSize: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaSetDoubleForDevice(d: *mut f64) -> root::cudaError_t;
        pub fn cudaSetDoubleForHost(d: *mut f64) -> root::cudaError_t;
        pub fn cudaLaunchHostFunc(
            stream: root::cudaStream_t,
            fn_: root::cudaHostFn_t,
            userData: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaFuncSetSharedMemConfig(
            func: *const ::core::ffi::c_void,
            config: root::cudaSharedMemConfig,
        ) -> root::cudaError_t;
        pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessor(
            numBlocks: *mut ::core::ffi::c_int,
            func: *const ::core::ffi::c_void,
            blockSize: ::core::ffi::c_int,
            dynamicSMemSize: usize,
        ) -> root::cudaError_t;
        pub fn cudaOccupancyAvailableDynamicSMemPerBlock(
            dynamicSmemSize: *mut usize,
            func: *const ::core::ffi::c_void,
            numBlocks: ::core::ffi::c_int,
            blockSize: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
            numBlocks: *mut ::core::ffi::c_int,
            func: *const ::core::ffi::c_void,
            blockSize: ::core::ffi::c_int,
            dynamicSMemSize: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaOccupancyMaxPotentialClusterSize(
            clusterSize: *mut ::core::ffi::c_int,
            func: *const ::core::ffi::c_void,
            launchConfig: *const root::cudaLaunchConfig_t,
        ) -> root::cudaError_t;
        pub fn cudaOccupancyMaxActiveClusters(
            numClusters: *mut ::core::ffi::c_int,
            func: *const ::core::ffi::c_void,
            launchConfig: *const root::cudaLaunchConfig_t,
        ) -> root::cudaError_t;
        pub fn cudaMallocManaged(
            devPtr: *mut *mut ::core::ffi::c_void,
            size: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaMalloc(devPtr: *mut *mut ::core::ffi::c_void, size: usize) -> root::cudaError_t;
        pub fn cudaMallocHost(ptr: *mut *mut ::core::ffi::c_void, size: usize)
            -> root::cudaError_t;
        pub fn cudaMallocPitch(
            devPtr: *mut *mut ::core::ffi::c_void,
            pitch: *mut usize,
            width: usize,
            height: usize,
        ) -> root::cudaError_t;
        pub fn cudaMallocArray(
            array: *mut root::cudaArray_t,
            desc: *const root::cudaChannelFormatDesc,
            width: usize,
            height: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaFree(devPtr: *mut ::core::ffi::c_void) -> root::cudaError_t;
        pub fn cudaFreeHost(ptr: *mut ::core::ffi::c_void) -> root::cudaError_t;
        pub fn cudaFreeArray(array: root::cudaArray_t) -> root::cudaError_t;
        pub fn cudaFreeMipmappedArray(
            mipmappedArray: root::cudaMipmappedArray_t,
        ) -> root::cudaError_t;
        pub fn cudaHostAlloc(
            pHost: *mut *mut ::core::ffi::c_void,
            size: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaHostRegister(
            ptr: *mut ::core::ffi::c_void,
            size: usize,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaHostUnregister(ptr: *mut ::core::ffi::c_void) -> root::cudaError_t;
        pub fn cudaHostGetDevicePointer(
            pDevice: *mut *mut ::core::ffi::c_void,
            pHost: *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaHostGetFlags(
            pFlags: *mut ::core::ffi::c_uint,
            pHost: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaMalloc3D(
            pitchedDevPtr: *mut root::cudaPitchedPtr,
            extent: root::cudaExtent,
        ) -> root::cudaError_t;
        pub fn cudaMalloc3DArray(
            array: *mut root::cudaArray_t,
            desc: *const root::cudaChannelFormatDesc,
            extent: root::cudaExtent,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaMallocMipmappedArray(
            mipmappedArray: *mut root::cudaMipmappedArray_t,
            desc: *const root::cudaChannelFormatDesc,
            extent: root::cudaExtent,
            numLevels: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGetMipmappedArrayLevel(
            levelArray: *mut root::cudaArray_t,
            mipmappedArray: root::cudaMipmappedArray_const_t,
            level: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy3D(p: *const root::cudaMemcpy3DParms) -> root::cudaError_t;
        pub fn cudaMemcpy3DPeer(p: *const root::cudaMemcpy3DPeerParms) -> root::cudaError_t;
        pub fn cudaMemcpy3DAsync(
            p: *const root::cudaMemcpy3DParms,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy3DPeerAsync(
            p: *const root::cudaMemcpy3DPeerParms,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemGetInfo(free: *mut usize, total: *mut usize) -> root::cudaError_t;
        pub fn cudaArrayGetInfo(
            desc: *mut root::cudaChannelFormatDesc,
            extent: *mut root::cudaExtent,
            flags: *mut ::core::ffi::c_uint,
            array: root::cudaArray_t,
        ) -> root::cudaError_t;
        pub fn cudaArrayGetPlane(
            pPlaneArray: *mut root::cudaArray_t,
            hArray: root::cudaArray_t,
            planeIdx: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaArrayGetMemoryRequirements(
            memoryRequirements: *mut root::cudaArrayMemoryRequirements,
            array: root::cudaArray_t,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaMipmappedArrayGetMemoryRequirements(
            memoryRequirements: *mut root::cudaArrayMemoryRequirements,
            mipmap: root::cudaMipmappedArray_t,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaArrayGetSparseProperties(
            sparseProperties: *mut root::cudaArraySparseProperties,
            array: root::cudaArray_t,
        ) -> root::cudaError_t;
        pub fn cudaMipmappedArrayGetSparseProperties(
            sparseProperties: *mut root::cudaArraySparseProperties,
            mipmap: root::cudaMipmappedArray_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy(
            dst: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyPeer(
            dst: *mut ::core::ffi::c_void,
            dstDevice: ::core::ffi::c_int,
            src: *const ::core::ffi::c_void,
            srcDevice: ::core::ffi::c_int,
            count: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2D(
            dst: *mut ::core::ffi::c_void,
            dpitch: usize,
            src: *const ::core::ffi::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DToArray(
            dst: root::cudaArray_t,
            wOffset: usize,
            hOffset: usize,
            src: *const ::core::ffi::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DFromArray(
            dst: *mut ::core::ffi::c_void,
            dpitch: usize,
            src: root::cudaArray_const_t,
            wOffset: usize,
            hOffset: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DArrayToArray(
            dst: root::cudaArray_t,
            wOffsetDst: usize,
            hOffsetDst: usize,
            src: root::cudaArray_const_t,
            wOffsetSrc: usize,
            hOffsetSrc: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyToSymbol(
            symbol: *const ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyFromSymbol(
            dst: *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyAsync(
            dst: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyPeerAsync(
            dst: *mut ::core::ffi::c_void,
            dstDevice: ::core::ffi::c_int,
            src: *const ::core::ffi::c_void,
            srcDevice: ::core::ffi::c_int,
            count: usize,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DAsync(
            dst: *mut ::core::ffi::c_void,
            dpitch: usize,
            src: *const ::core::ffi::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DToArrayAsync(
            dst: root::cudaArray_t,
            wOffset: usize,
            hOffset: usize,
            src: *const ::core::ffi::c_void,
            spitch: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpy2DFromArrayAsync(
            dst: *mut ::core::ffi::c_void,
            dpitch: usize,
            src: root::cudaArray_const_t,
            wOffset: usize,
            hOffset: usize,
            width: usize,
            height: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyToSymbolAsync(
            symbol: *const ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyFromSymbolAsync(
            dst: *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemset(
            devPtr: *mut ::core::ffi::c_void,
            value: ::core::ffi::c_int,
            count: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemset2D(
            devPtr: *mut ::core::ffi::c_void,
            pitch: usize,
            value: ::core::ffi::c_int,
            width: usize,
            height: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemset3D(
            pitchedDevPtr: root::cudaPitchedPtr,
            value: ::core::ffi::c_int,
            extent: root::cudaExtent,
        ) -> root::cudaError_t;
        pub fn cudaMemsetAsync(
            devPtr: *mut ::core::ffi::c_void,
            value: ::core::ffi::c_int,
            count: usize,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemset2DAsync(
            devPtr: *mut ::core::ffi::c_void,
            pitch: usize,
            value: ::core::ffi::c_int,
            width: usize,
            height: usize,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemset3DAsync(
            pitchedDevPtr: root::cudaPitchedPtr,
            value: ::core::ffi::c_int,
            extent: root::cudaExtent,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaGetSymbolAddress(
            devPtr: *mut *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaGetSymbolSize(
            size: *mut usize,
            symbol: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaMemPrefetchAsync(
            devPtr: *const ::core::ffi::c_void,
            count: usize,
            dstDevice: ::core::ffi::c_int,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemPrefetchAsync_v2(
            devPtr: *const ::core::ffi::c_void,
            count: usize,
            location: root::cudaMemLocation,
            flags: ::core::ffi::c_uint,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemAdvise(
            devPtr: *const ::core::ffi::c_void,
            count: usize,
            advice: root::cudaMemoryAdvise,
            device: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaMemAdvise_v2(
            devPtr: *const ::core::ffi::c_void,
            count: usize,
            advice: root::cudaMemoryAdvise,
            location: root::cudaMemLocation,
        ) -> root::cudaError_t;
        pub fn cudaMemRangeGetAttribute(
            data: *mut ::core::ffi::c_void,
            dataSize: usize,
            attribute: root::cudaMemRangeAttribute,
            devPtr: *const ::core::ffi::c_void,
            count: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemRangeGetAttributes(
            data: *mut *mut ::core::ffi::c_void,
            dataSizes: *mut usize,
            attributes: *mut root::cudaMemRangeAttribute,
            numAttributes: usize,
            devPtr: *const ::core::ffi::c_void,
            count: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyToArray(
            dst: root::cudaArray_t,
            wOffset: usize,
            hOffset: usize,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyFromArray(
            dst: *mut ::core::ffi::c_void,
            src: root::cudaArray_const_t,
            wOffset: usize,
            hOffset: usize,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyArrayToArray(
            dst: root::cudaArray_t,
            wOffsetDst: usize,
            hOffsetDst: usize,
            src: root::cudaArray_const_t,
            wOffsetSrc: usize,
            hOffsetSrc: usize,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyToArrayAsync(
            dst: root::cudaArray_t,
            wOffset: usize,
            hOffset: usize,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemcpyFromArrayAsync(
            dst: *mut ::core::ffi::c_void,
            src: root::cudaArray_const_t,
            wOffset: usize,
            hOffset: usize,
            count: usize,
            kind: root::cudaMemcpyKind,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMallocAsync(
            devPtr: *mut *mut ::core::ffi::c_void,
            size: usize,
            hStream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaFreeAsync(
            devPtr: *mut ::core::ffi::c_void,
            hStream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolTrimTo(
            memPool: root::cudaMemPool_t,
            minBytesToKeep: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolSetAttribute(
            memPool: root::cudaMemPool_t,
            attr: root::cudaMemPoolAttr,
            value: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolGetAttribute(
            memPool: root::cudaMemPool_t,
            attr: root::cudaMemPoolAttr,
            value: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolSetAccess(
            memPool: root::cudaMemPool_t,
            descList: *const root::cudaMemAccessDesc,
            count: usize,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolGetAccess(
            flags: *mut root::cudaMemAccessFlags,
            memPool: root::cudaMemPool_t,
            location: *mut root::cudaMemLocation,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolCreate(
            memPool: *mut root::cudaMemPool_t,
            poolProps: *const root::cudaMemPoolProps,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolDestroy(memPool: root::cudaMemPool_t) -> root::cudaError_t;
        pub fn cudaMallocFromPoolAsync(
            ptr: *mut *mut ::core::ffi::c_void,
            size: usize,
            memPool: root::cudaMemPool_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolExportToShareableHandle(
            shareableHandle: *mut ::core::ffi::c_void,
            memPool: root::cudaMemPool_t,
            handleType: root::cudaMemAllocationHandleType,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolImportFromShareableHandle(
            memPool: *mut root::cudaMemPool_t,
            shareableHandle: *mut ::core::ffi::c_void,
            handleType: root::cudaMemAllocationHandleType,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolExportPointer(
            exportData: *mut root::cudaMemPoolPtrExportData,
            ptr: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaMemPoolImportPointer(
            ptr: *mut *mut ::core::ffi::c_void,
            memPool: root::cudaMemPool_t,
            exportData: *mut root::cudaMemPoolPtrExportData,
        ) -> root::cudaError_t;
        pub fn cudaPointerGetAttributes(
            attributes: *mut root::cudaPointerAttributes,
            ptr: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaDeviceCanAccessPeer(
            canAccessPeer: *mut ::core::ffi::c_int,
            device: ::core::ffi::c_int,
            peerDevice: ::core::ffi::c_int,
        ) -> root::cudaError_t;
        pub fn cudaDeviceEnablePeerAccess(
            peerDevice: ::core::ffi::c_int,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaDeviceDisablePeerAccess(peerDevice: ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaGraphicsUnregisterResource(
            resource: root::cudaGraphicsResource_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsResourceSetMapFlags(
            resource: root::cudaGraphicsResource_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsMapResources(
            count: ::core::ffi::c_int,
            resources: *mut root::cudaGraphicsResource_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsUnmapResources(
            count: ::core::ffi::c_int,
            resources: *mut root::cudaGraphicsResource_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsResourceGetMappedPointer(
            devPtr: *mut *mut ::core::ffi::c_void,
            size: *mut usize,
            resource: root::cudaGraphicsResource_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsSubResourceGetMappedArray(
            array: *mut root::cudaArray_t,
            resource: root::cudaGraphicsResource_t,
            arrayIndex: ::core::ffi::c_uint,
            mipLevel: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphicsResourceGetMappedMipmappedArray(
            mipmappedArray: *mut root::cudaMipmappedArray_t,
            resource: root::cudaGraphicsResource_t,
        ) -> root::cudaError_t;
        pub fn cudaGetChannelDesc(
            desc: *mut root::cudaChannelFormatDesc,
            array: root::cudaArray_const_t,
        ) -> root::cudaError_t;
        pub fn cudaCreateChannelDesc(
            x: ::core::ffi::c_int,
            y: ::core::ffi::c_int,
            z: ::core::ffi::c_int,
            w: ::core::ffi::c_int,
            f: root::cudaChannelFormatKind,
        ) -> root::cudaChannelFormatDesc;
        pub fn cudaCreateTextureObject(
            pTexObject: *mut root::cudaTextureObject_t,
            pResDesc: *const root::cudaResourceDesc,
            pTexDesc: *const root::cudaTextureDesc,
            pResViewDesc: *const root::cudaResourceViewDesc,
        ) -> root::cudaError_t;
        pub fn cudaDestroyTextureObject(texObject: root::cudaTextureObject_t) -> root::cudaError_t;
        pub fn cudaGetTextureObjectResourceDesc(
            pResDesc: *mut root::cudaResourceDesc,
            texObject: root::cudaTextureObject_t,
        ) -> root::cudaError_t;
        pub fn cudaGetTextureObjectTextureDesc(
            pTexDesc: *mut root::cudaTextureDesc,
            texObject: root::cudaTextureObject_t,
        ) -> root::cudaError_t;
        pub fn cudaGetTextureObjectResourceViewDesc(
            pResViewDesc: *mut root::cudaResourceViewDesc,
            texObject: root::cudaTextureObject_t,
        ) -> root::cudaError_t;
        pub fn cudaCreateSurfaceObject(
            pSurfObject: *mut root::cudaSurfaceObject_t,
            pResDesc: *const root::cudaResourceDesc,
        ) -> root::cudaError_t;
        pub fn cudaDestroySurfaceObject(surfObject: root::cudaSurfaceObject_t)
            -> root::cudaError_t;
        pub fn cudaGetSurfaceObjectResourceDesc(
            pResDesc: *mut root::cudaResourceDesc,
            surfObject: root::cudaSurfaceObject_t,
        ) -> root::cudaError_t;
        pub fn cudaDriverGetVersion(driverVersion: *mut ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaRuntimeGetVersion(runtimeVersion: *mut ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaGraphCreate(
            pGraph: *mut root::cudaGraph_t,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddKernelNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            pNodeParams: *const root::cudaKernelNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphKernelNodeGetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *mut root::cudaKernelNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphKernelNodeSetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaKernelNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphKernelNodeCopyAttributes(
            hSrc: root::cudaGraphNode_t,
            hDst: root::cudaGraphNode_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphKernelNodeGetAttribute(
            hNode: root::cudaGraphNode_t,
            attr: root::cudaLaunchAttributeID,
            value_out: *mut root::cudaLaunchAttributeValue,
        ) -> root::cudaError_t;
        pub fn cudaGraphKernelNodeSetAttribute(
            hNode: root::cudaGraphNode_t,
            attr: root::cudaLaunchAttributeID,
            value: *const root::cudaLaunchAttributeValue,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemcpyNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            pCopyParams: *const root::cudaMemcpy3DParms,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemcpyNodeToSymbol(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            symbol: *const ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemcpyNodeFromSymbol(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            dst: *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemcpyNode1D(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            dst: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemcpyNodeGetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *mut root::cudaMemcpy3DParms,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemcpyNodeSetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaMemcpy3DParms,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemcpyNodeSetParamsToSymbol(
            node: root::cudaGraphNode_t,
            symbol: *const ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemcpyNodeSetParamsFromSymbol(
            node: root::cudaGraphNode_t,
            dst: *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemcpyNodeSetParams1D(
            node: root::cudaGraphNode_t,
            dst: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemsetNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            pMemsetParams: *const root::cudaMemsetParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemsetNodeGetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *mut root::cudaMemsetParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemsetNodeSetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaMemsetParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddHostNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            pNodeParams: *const root::cudaHostNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphHostNodeGetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *mut root::cudaHostNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphHostNodeSetParams(
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaHostNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddChildGraphNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            childGraph: root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphChildGraphNodeGetGraph(
            node: root::cudaGraphNode_t,
            pGraph: *mut root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddEmptyNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddEventRecordNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphEventRecordNodeGetEvent(
            node: root::cudaGraphNode_t,
            event_out: *mut root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphEventRecordNodeSetEvent(
            node: root::cudaGraphNode_t,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddEventWaitNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphEventWaitNodeGetEvent(
            node: root::cudaGraphNode_t,
            event_out: *mut root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphEventWaitNodeSetEvent(
            node: root::cudaGraphNode_t,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddExternalSemaphoresSignalNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            nodeParams: *const root::cudaExternalSemaphoreSignalNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExternalSemaphoresSignalNodeGetParams(
            hNode: root::cudaGraphNode_t,
            params_out: *mut root::cudaExternalSemaphoreSignalNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExternalSemaphoresSignalNodeSetParams(
            hNode: root::cudaGraphNode_t,
            nodeParams: *const root::cudaExternalSemaphoreSignalNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddExternalSemaphoresWaitNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            nodeParams: *const root::cudaExternalSemaphoreWaitNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExternalSemaphoresWaitNodeGetParams(
            hNode: root::cudaGraphNode_t,
            params_out: *mut root::cudaExternalSemaphoreWaitNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExternalSemaphoresWaitNodeSetParams(
            hNode: root::cudaGraphNode_t,
            nodeParams: *const root::cudaExternalSemaphoreWaitNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemAllocNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            nodeParams: *mut root::cudaMemAllocNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemAllocNodeGetParams(
            node: root::cudaGraphNode_t,
            params_out: *mut root::cudaMemAllocNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddMemFreeNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            dptr: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaGraphMemFreeNodeGetParams(
            node: root::cudaGraphNode_t,
            dptr_out: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaDeviceGraphMemTrim(device: ::core::ffi::c_int) -> root::cudaError_t;
        pub fn cudaDeviceGetGraphMemAttribute(
            device: ::core::ffi::c_int,
            attr: root::cudaGraphMemAttributeType,
            value: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaDeviceSetGraphMemAttribute(
            device: ::core::ffi::c_int,
            attr: root::cudaGraphMemAttributeType,
            value: *mut ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaGraphClone(
            pGraphClone: *mut root::cudaGraph_t,
            originalGraph: root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeFindInClone(
            pNode: *mut root::cudaGraphNode_t,
            originalNode: root::cudaGraphNode_t,
            clonedGraph: root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetType(
            node: root::cudaGraphNode_t,
            pType: *mut root::cudaGraphNodeType,
        ) -> root::cudaError_t;
        pub fn cudaGraphGetNodes(
            graph: root::cudaGraph_t,
            nodes: *mut root::cudaGraphNode_t,
            numNodes: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphGetRootNodes(
            graph: root::cudaGraph_t,
            pRootNodes: *mut root::cudaGraphNode_t,
            pNumRootNodes: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphGetEdges(
            graph: root::cudaGraph_t,
            from: *mut root::cudaGraphNode_t,
            to: *mut root::cudaGraphNode_t,
            numEdges: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphGetEdges_v2(
            graph: root::cudaGraph_t,
            from: *mut root::cudaGraphNode_t,
            to: *mut root::cudaGraphNode_t,
            edgeData: *mut root::cudaGraphEdgeData,
            numEdges: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetDependencies(
            node: root::cudaGraphNode_t,
            pDependencies: *mut root::cudaGraphNode_t,
            pNumDependencies: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetDependencies_v2(
            node: root::cudaGraphNode_t,
            pDependencies: *mut root::cudaGraphNode_t,
            edgeData: *mut root::cudaGraphEdgeData,
            pNumDependencies: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetDependentNodes(
            node: root::cudaGraphNode_t,
            pDependentNodes: *mut root::cudaGraphNode_t,
            pNumDependentNodes: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetDependentNodes_v2(
            node: root::cudaGraphNode_t,
            pDependentNodes: *mut root::cudaGraphNode_t,
            edgeData: *mut root::cudaGraphEdgeData,
            pNumDependentNodes: *mut usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddDependencies(
            graph: root::cudaGraph_t,
            from: *const root::cudaGraphNode_t,
            to: *const root::cudaGraphNode_t,
            numDependencies: usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddDependencies_v2(
            graph: root::cudaGraph_t,
            from: *const root::cudaGraphNode_t,
            to: *const root::cudaGraphNode_t,
            edgeData: *const root::cudaGraphEdgeData,
            numDependencies: usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphRemoveDependencies(
            graph: root::cudaGraph_t,
            from: *const root::cudaGraphNode_t,
            to: *const root::cudaGraphNode_t,
            numDependencies: usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphRemoveDependencies_v2(
            graph: root::cudaGraph_t,
            from: *const root::cudaGraphNode_t,
            to: *const root::cudaGraphNode_t,
            edgeData: *const root::cudaGraphEdgeData,
            numDependencies: usize,
        ) -> root::cudaError_t;
        pub fn cudaGraphDestroyNode(node: root::cudaGraphNode_t) -> root::cudaError_t;
        pub fn cudaGraphInstantiate(
            pGraphExec: *mut root::cudaGraphExec_t,
            graph: root::cudaGraph_t,
            flags: ::core::ffi::c_ulonglong,
        ) -> root::cudaError_t;
        pub fn cudaGraphInstantiateWithFlags(
            pGraphExec: *mut root::cudaGraphExec_t,
            graph: root::cudaGraph_t,
            flags: ::core::ffi::c_ulonglong,
        ) -> root::cudaError_t;
        pub fn cudaGraphInstantiateWithParams(
            pGraphExec: *mut root::cudaGraphExec_t,
            graph: root::cudaGraph_t,
            instantiateParams: *mut root::cudaGraphInstantiateParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecGetFlags(
            graphExec: root::cudaGraphExec_t,
            flags: *mut ::core::ffi::c_ulonglong,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecKernelNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaKernelNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecMemcpyNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaMemcpy3DParms,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecMemcpyNodeSetParamsToSymbol(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            symbol: *const ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecMemcpyNodeSetParamsFromSymbol(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            dst: *mut ::core::ffi::c_void,
            symbol: *const ::core::ffi::c_void,
            count: usize,
            offset: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecMemcpyNodeSetParams1D(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            dst: *mut ::core::ffi::c_void,
            src: *const ::core::ffi::c_void,
            count: usize,
            kind: root::cudaMemcpyKind,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecMemsetNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaMemsetParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecHostNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            pNodeParams: *const root::cudaHostNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecChildGraphNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            childGraph: root::cudaGraph_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecEventRecordNodeSetEvent(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecEventWaitNodeSetEvent(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            event: root::cudaEvent_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecExternalSemaphoresSignalNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            nodeParams: *const root::cudaExternalSemaphoreSignalNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecExternalSemaphoresWaitNodeSetParams(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            nodeParams: *const root::cudaExternalSemaphoreWaitNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeSetEnabled(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            isEnabled: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeGetEnabled(
            hGraphExec: root::cudaGraphExec_t,
            hNode: root::cudaGraphNode_t,
            isEnabled: *mut ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecUpdate(
            hGraphExec: root::cudaGraphExec_t,
            hGraph: root::cudaGraph_t,
            resultInfo: *mut root::cudaGraphExecUpdateResultInfo,
        ) -> root::cudaError_t;
        pub fn cudaGraphUpload(
            graphExec: root::cudaGraphExec_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphLaunch(
            graphExec: root::cudaGraphExec_t,
            stream: root::cudaStream_t,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecDestroy(graphExec: root::cudaGraphExec_t) -> root::cudaError_t;
        pub fn cudaGraphDestroy(graph: root::cudaGraph_t) -> root::cudaError_t;
        pub fn cudaGraphDebugDotPrint(
            graph: root::cudaGraph_t,
            path: *const ::core::ffi::c_char,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaUserObjectCreate(
            object_out: *mut root::cudaUserObject_t,
            ptr: *mut ::core::ffi::c_void,
            destroy: root::cudaHostFn_t,
            initialRefcount: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaUserObjectRetain(
            object: root::cudaUserObject_t,
            count: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaUserObjectRelease(
            object: root::cudaUserObject_t,
            count: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphRetainUserObject(
            graph: root::cudaGraph_t,
            object: root::cudaUserObject_t,
            count: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphReleaseUserObject(
            graph: root::cudaGraph_t,
            object: root::cudaUserObject_t,
            count: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddNode(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            numDependencies: usize,
            nodeParams: *mut root::cudaGraphNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphAddNode_v2(
            pGraphNode: *mut root::cudaGraphNode_t,
            graph: root::cudaGraph_t,
            pDependencies: *const root::cudaGraphNode_t,
            dependencyData: *const root::cudaGraphEdgeData,
            numDependencies: usize,
            nodeParams: *mut root::cudaGraphNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphNodeSetParams(
            node: root::cudaGraphNode_t,
            nodeParams: *mut root::cudaGraphNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphExecNodeSetParams(
            graphExec: root::cudaGraphExec_t,
            node: root::cudaGraphNode_t,
            nodeParams: *mut root::cudaGraphNodeParams,
        ) -> root::cudaError_t;
        pub fn cudaGraphConditionalHandleCreate(
            pHandle_out: *mut root::cudaGraphConditionalHandle,
            graph: root::cudaGraph_t,
            defaultLaunchValue: ::core::ffi::c_uint,
            flags: ::core::ffi::c_uint,
        ) -> root::cudaError_t;
        pub fn cudaGetDriverEntryPoint(
            symbol: *const ::core::ffi::c_char,
            funcPtr: *mut *mut ::core::ffi::c_void,
            flags: ::core::ffi::c_ulonglong,
            driverStatus: *mut root::cudaDriverEntryPointQueryResult,
        ) -> root::cudaError_t;
        pub fn cudaGetDriverEntryPointByVersion(
            symbol: *const ::core::ffi::c_char,
            funcPtr: *mut *mut ::core::ffi::c_void,
            cudaVersion: ::core::ffi::c_uint,
            flags: ::core::ffi::c_ulonglong,
            driverStatus: *mut root::cudaDriverEntryPointQueryResult,
        ) -> root::cudaError_t;
        pub fn cudaGetExportTable(
            ppExportTable: *mut *const ::core::ffi::c_void,
            pExportTableId: *const root::cudaUUID_t,
        ) -> root::cudaError_t;
        pub fn cudaGetFuncBySymbol(
            functionPtr: *mut root::cudaFunction_t,
            symbolPtr: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn cudaGetKernel(
            kernelPtr: *mut root::cudaKernel_t,
            entryFuncAddr: *const ::core::ffi::c_void,
        ) -> root::cudaError_t;
        pub fn createInferRuntime_INTERNAL(
            logger: *mut ::core::ffi::c_void,
            version: i32,
        ) -> *mut ::core::ffi::c_void;
        pub fn createInferRefitter_INTERNAL(
            engine: *mut ::core::ffi::c_void,
            logger: *mut ::core::ffi::c_void,
            version: i32,
        ) -> *mut ::core::ffi::c_void;
        pub fn createInferBuilder_INTERNAL(
            logger: *mut ::core::ffi::c_void,
            version: i32,
        ) -> *mut ::core::ffi::c_void;
        pub fn createNvOnnxParser_INTERNAL(
            network: *mut ::core::ffi::c_void,
            logger: *mut ::core::ffi::c_void,
            version: ::core::ffi::c_int,
        ) -> *mut ::core::ffi::c_void;
        pub fn createNvOnnxParserRefitter_INTERNAL(
            refitter: *mut ::core::ffi::c_void,
            logger: *mut ::core::ffi::c_void,
            version: i32,
        ) -> *mut ::core::ffi::c_void;
    }
}
